#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
Module Name         :   Business Rules Handler
Purpose             :   Module to define application logic for the fast services for Business Rules tab performing
                        below operations -
                            a. Fetching rule and catrgory information
                            b. To edit, create new business rule
Pre_requisites      :   NA
Input Parameters    :   NA
Output              :   Returns response containing the output and status message.
Execution Steps     :   NA
Last changed on     :   9 June 2021
Last changed by     :   Harshal Taware
Reason for change   :   NA
"""

__author__ = 'ZS Associates'
__license__ = 'This file is subject to the terms and conditions defined in file "LICENSE.txt" which is part of this source code package.'

import json
import os
import asyncio
import traceback
import uuid
from calendar import monthrange
from datetime import datetime, time
from io import BytesIO
from itertools import groupby
from operator import itemgetter
import awswrangler as wr
import logging
import boto3
# import pyspark

import pandas as pd
from fastapi import HTTPException
from pymysql import IntegrityError
from botocore.errorfactory import ClientError
from scripts.config import app_constants, app_configurations
from scripts.config.app_constants import BusinessRulesForms
from scripts.core.models.business_rules_model import SegmentationRuleDetails, PatientTaggingDetails, \
    SystemParamsDetails
from scripts.core.queries import business_rules_queries
from scripts.core.queries import approval_requests_queries
from scripts.logging.ccf_logging import logger as log
from scripts.utilities.audit_log_utility import AuditLogUtility
from scripts.utilities.ccf_data_utility import CCFDataUtility
from scripts.utilities.common_utility import get_boto3_session, CommonUtility

service_directory_path = os.path.dirname(os.path.abspath(__file__))
utilities_dir_path = os.path.abspath(
    os.path.join(service_directory_path, "../../utilities/"))
config_dir_path = os.path.abspath(
    os.path.join(service_directory_path, "../../../conf/"))


def client_error(err):
    log.info("Handling client error")
    if err.response['Error']['Code'] == "NoSuchBucket":
        raise HTTPException(status_code=404, detail=str(err.response['Error']['Message'])) from err
    if err.response['Error']['Code'] == "AccessDenied":
        raise HTTPException(status_code=403, detail=(
            "Either you are not authorized or the specified S3 bucket doesn't exist. Please contact admin")) from err
    log.error(err)
    raise HTTPException(status_code=500, detail=str(err)) from err


class BusinessRulesHandler:
    """
    This class contains all the services for Business Rules tab
    """

    def __init__(self, db_object):
        try:
            self.db_obj = db_object
            self.audit_obj = AuditLogUtility()
        except Exception as error:
            log.error(error)
            raise Exception("Error while establishing connection to database") from error

    def get_rule_category(self):
        """
        :return: list of rule categories and details
        """
        try:
            response_list = []
            rule_category_name_list = app_constants.BusinessRules.rule_category_name_list
            for rule_category in rule_category_name_list:
                response = dict(value="", label="")
                response[app_constants.CommonConstants.KEY_VALUE] = \
                    rule_category[
                        app_constants.ApprovalRequests.KEY_RULE_CATEGORY_NAME]
                response[app_constants.CommonConstants.KEY_LABEL] = \
                    rule_category[
                        app_constants.ApprovalRequests.KEY_RULE_CATEGORY_NAME]
                response_list.append(response)

            if len(response_list) == 0:
                response_list = []
            log.debug("Fetched rule category details")
            return response_list

        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj

    def load_alignment_business_rule_form(self, request_body, role_id):
        """
        :param request_body: input parameters from UI
        :return: status of rule created
        """
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch alignment details. Please contact admin")
            rule_category_name = request_body.rule_category_name
            payload_json = dict()
            if rule_category_name == app_constants.BusinessRules.KEY_ALIGNMENT_RULE:
                rule_set_json = dict()
                s3_staging_dir = config_details['athena_s3_staging_dir']
                user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
                boto_session = get_boto3_session(assume_role_arn=user_iam_role)
                log.info("Getting alignment details...")
                market_names_query = business_rules_queries.market_names_query
                log.debug("Query to fetch market names:\n%s", market_names_query)
                market_names = wr.athena.read_sql_query(sql=market_names_query,
                                                     database=app_configurations.BUSINESS_RULES_DW_DB,
                                                     ctas_approach=False,
                                                     max_cache_seconds=900,
                                                     max_local_cache_entries=200,
                                                     max_cache_query_inspections = 50,
                                                     s3_output=s3_staging_dir,
                                                     boto3_session=boto_session)
                market_names = json.loads(market_names.to_json(orient="records"))
                log.info("Market Names: %s", market_names)

                sales_force_names_query = business_rules_queries.sales_force_names_query
                log.debug("Query to fetch sales force names:\n%s", sales_force_names_query)
                salesforce_names = self.db_obj.raw_query(sales_force_names_query)
                salesforce_name_list = {}
                for i in salesforce_names:
                    if not i[
                               app_constants.BusinessRules.KEY_MARKET] in salesforce_name_list.keys():
                        salesforce_name_list[
                            i[app_constants.BusinessRules.KEY_MARKET]] = [
                            {app_constants.BusinessRules.KEY_BIND_VALUE: i[
                                app_constants.BusinessRules.KEY_SALES_FORCE],
                             app_constants.BusinessRules.KEY_BIND_LABEL: i[
                                 app_constants.BusinessRules.KEY_SALES_FORCE]
                             }]
                    else:
                        salesforce_name_list[
                            i[app_constants.BusinessRules.KEY_MARKET]].append(
                            {app_constants.BusinessRules.KEY_BIND_VALUE: i[
                                app_constants.BusinessRules.KEY_SALES_FORCE],
                             app_constants.BusinessRules.KEY_BIND_LABEL: i[
                                 app_constants.BusinessRules.KEY_SALES_FORCE]
                             })
                primary_speciality_mapping_query = business_rules_queries.primary_speciality_mapping_query
                log.debug("Query to fetch primary speciality names:\n%s",
                          primary_speciality_mapping_query)
                speciality_values = self.db_obj.raw_query(
                    primary_speciality_mapping_query)

                primary_entity_classification_query = business_rules_queries.primary_entity_classification_query
                log.debug("Query to fetch entity classification names:\n%s",
                          primary_entity_classification_query)
                entity_classification_values = self.db_obj.raw_query(
                    primary_entity_classification_query)

                alignment_form, customer_inclusion, customer_overrides, data = app_constants.BusinessRules().business_rules_alignment_form(
                    market_names, salesforce_name_list, speciality_values,
                    entity_classification_values)
                rule_set_json[
                    app_constants.BusinessRules.KEY_FORM_FIELDS] = alignment_form
                rule_set_json[
                    app_constants.BusinessRules.KEY_CUSTOMER_INCLUSION] = customer_inclusion
                rule_set_json[
                    app_constants.BusinessRules.KEY_CUSTOMER_OVERRIDES] = customer_overrides
                rule_set_json[app_constants.BusinessRules.KEY_DATA] = data

                payload_json[
                    app_constants.BusinessRules.KEY_RULESET] = rule_set_json

                return payload_json
            return payload_json

        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj

    def create_alignment_business_rule(self, userid, roleid, request_body,
                                       uploaded_file_for_inclusion,
                                       uploaded_file_for_overrides,
                                       inclusion_upload, override_upload):
        """
        :param userid: username of the logged in user
        :param roleid: id of the role assigned to that user
        :param request_body: input parameters from UI
        :return: status of rule created
        """
        try:
            market_name = ""
            salesforce_name = ""
            customer_type = ""
            alignment_quarter = ""
            ic_frozen_alignment_flag = ""
            attribute_based_exclusuion_flag = ""
            customer_overrides_flag = ""
            ztt_flag = ""
            attribute_type_kaiser_flag = ""
            attribute_type_speciality_list = ""
            attribute_type_active_flag = ""
            attribute_type_file_name_pattern = ""
            attribute_type_entity_classification_list = ""
            attribute_type_account_active_flag = ""
            customer_inclusion = ""
            customer_overrides = ""
            frozen_alignment_snapshot_data_date = ""

            for key, value in request_body.items():
                market_name = value[app_constants.BusinessRules.KEY_MKT_NM]
                salesforce_name = value[
                    app_constants.BusinessRules.KEY_SLS_FRC_NM]
                customer_type = value[app_constants.BusinessRules.KEY_PTY_TYPE].upper()
                alignment_quarter = value[
                    app_constants.BusinessRules.KEY_ALIGT_QTR]
                ic_frozen_alignment_flag = value[
                    app_constants.BusinessRules.KEY_IS_FROZEN_FLG]
                attribute_based_exclusuion_flag = value[
                    app_constants.BusinessRules.KEY_ATTRIBUTE_BASED_EXCLUSUION]
                customer_overrides_flag = value[
                    app_constants.BusinessRules.KEY_CUSTOMER_OVERRIDES]
                ztt_flag = value[app_constants.BusinessRules.KEY_ZTT]
                attribute_type_kaiser_flag = value[
                    app_constants.BusinessRules.KEY_KAISER_FLG]
                attribute_type_speciality_list = value[
                    app_constants.BusinessRules.KEY_PRI_SPEC_CD]
                attribute_type_active_flag = value[
                    app_constants.BusinessRules.KEY_HCP_ACTV_FLG]
                attribute_type_file_name_pattern = value[
                    app_constants.BusinessRules.KEY_ACNT_NM]
                attribute_type_entity_classification_list = value[
                    app_constants.BusinessRules.KEY_COT_CD]
                attribute_type_account_active_flag = value[
                    app_constants.BusinessRules.KEY_ACNT_STAT]
                customer_inclusion = value[
                    app_constants.BusinessRules.KEY_INCLUSION_LIST]
                customer_overrides = value[
                    app_constants.BusinessRules.KEY_OVERRIDES_LIST]

                if ic_frozen_alignment_flag:
                    ic_frozen_alignment_flag = "Y"
                    frozen_alignment_snapshot_data_date = value[
                        app_constants.BusinessRules.KEY_DATA_DT]
                else:
                    ic_frozen_alignment_flag = "N"
                    frozen_alignment_snapshot_data_date = ""

            customer_inclusion_list = customer_inclusion
            customer_overrides_list = customer_overrides
            common_column_list_exclusuion = [
                {app_constants.BusinessRules.KEY_MKT_NM: market_name},
                {app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                {app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                {app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                {
                    app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag}]

            aligt_type_list = []
            aligt_prty_list = []
            if ztt_flag:
                aligt_type_list.append({app_constants.BusinessRules.KEY_ALIGT_TYPE: "ZTT"})
                aligt_prty_list.append({app_constants.BusinessRules.KEY_ALIGT_PRTY: "1"})
            if attribute_based_exclusuion_flag:
                if not ztt_flag:
                    aligt_type_list.append(
                        {app_constants.BusinessRules.KEY_ALIGT_TYPE: "ATTR_OVERRIDE"})
                    aligt_prty_list.append({app_constants.BusinessRules.KEY_ALIGT_PRTY: "1"})
                else:
                    aligt_type_list.append(
                        {app_constants.BusinessRules.KEY_ALIGT_TYPE: "ATTR_OVERRIDE"})
                    aligt_prty_list.append({app_constants.BusinessRules.KEY_ALIGT_PRTY: "2"})
            if customer_overrides_flag:
                if not ztt_flag and not attribute_based_exclusuion_flag:
                    aligt_type_list.append(
                        {app_constants.BusinessRules.KEY_ALIGT_TYPE: "CUST_OVERRIDE"})
                    aligt_prty_list.append({app_constants.BusinessRules.KEY_ALIGT_PRTY: "1"})
                if not ztt_flag and attribute_based_exclusuion_flag:
                    aligt_type_list.append(
                        {app_constants.BusinessRules.KEY_ALIGT_TYPE: "CUST_OVERRIDE"})
                    aligt_prty_list.append({app_constants.BusinessRules.KEY_ALIGT_PRTY: "2"})
                else:
                    aligt_type_list.append(
                        {app_constants.BusinessRules.KEY_ALIGT_TYPE: "CUST_OVERRIDE"})
                    aligt_prty_list.append({app_constants.BusinessRules.KEY_ALIGT_PRTY: "3"})

            insert_clause = ""
            for i in range(len(aligt_type_list)):
                business_rule_id = datetime.utcnow().strftime(
                    '%Y%m-%d%H-%M%S-') + str(
                    uuid.uuid4().hex[:8])
                column_list = [{app_constants.BusinessRules.KEY_MKT_NM: market_name},
                               {app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                               {app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                               {app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                               {
                                   app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                               {
                                   app_constants.BusinessRules.KEY_DATA_DT: frozen_alignment_snapshot_data_date},
                               aligt_type_list[i], aligt_prty_list[i]]
                key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                              app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                              app_constants.BusinessRules.KEY_INSERT_DATE]
                value_list_1 = [business_rule_id, "N",
                                datetime.utcnow().strftime('%Y-%m-%d')]
                for data in column_list:
                    for key, value in data.items():
                        key_list_1.append(key)
                        value_list_1.append(value)
                key_list = ','.join(key_list_1)
                value_list = "','".join(value_list_1)
                rule_value = {}
                for idx, value in enumerate(key_list_1):
                    rule_value[value] = value_list_1[idx]
                rule_value = json.dumps(rule_value)
                insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                create_rule_query = business_rules_queries.create_rule_query.format(
                    table_name=app_constants.BusinessRules.KEY_ALIGNMENT_CONFIG_TABLE,
                    insert_clause=insert_clause)
                log.debug("create rule query:\n%s", create_rule_query)
                try:
                    self.db_obj.raw_query(create_rule_query, auto_commit=False)
                except Exception as err:
                    raise Exception("Record is already present in alignment_config table") from err
                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_CONFIG,
                    rule_value=rule_value,
                    rule_id=business_rule_id,
                    userid=userid, roleid=roleid,
                    request_date=datetime.strftime(datetime.utcnow(),
                                                   "%Y-%m-%d %H:%M:%S"))

                log.debug(
                    "Query to send request for approval : %s", approval_request_query)
                self.db_obj.raw_query(approval_request_query, auto_commit=False)

            if attribute_based_exclusuion_flag:
                if customer_type.lower() == app_constants.BusinessRules.KEY_PRESCRIBER:
                    if attribute_type_kaiser_flag != True and attribute_type_active_flag != True and len(
                            attribute_type_speciality_list) == 0:
                        raise Exception(
                            "Please fill atleast one in attribute based exclusuion category")
                    if attribute_type_kaiser_flag:
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "KAISER_FLG", "Y", "KAISER_FLG", "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type prescriber "
                                "and attribute_type kaiser_flag") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if attribute_type_kaiser_flag == False:
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "KAISER_FLG", "N", "KAISER_FLG", "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type prescriber "
                                "and attribute_type kaiser_flag") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if attribute_type_active_flag:
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "HCP_ACTV_FLG", "Y", "HCP_ACTV_FLG",
                                        "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type prescriber "
                                "and attribute_type active_flag") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if attribute_type_active_flag == False:
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "HCP_ACTV_FLG", "N", "HCP_ACTV_FLG",
                                        "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type prescriber "
                                "and attribute_type active_flag") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if len(attribute_type_speciality_list):
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        speciality_list = []
                        for speciality in attribute_type_speciality_list:
                            speciality_list.append({"ATTR_VAL": speciality})

                        for i, item in enumerate(speciality_list):
                            column_list_new = [
                                {app_constants.BusinessRules.KEY_MKT_NM: market_name},
                                {app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                                {app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                                {app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                                {
                                    app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                                item]
                            key_list_1 = [
                                app_constants.BusinessRules.KEY_RULE_ID,
                                app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                app_constants.BusinessRules.KEY_INSERT_DATE,
                                app_constants.BusinessRules.KEY_ATTR_TYPE,
                                app_constants.BusinessRules.KEY_EXCL_FLG,
                                app_constants.BusinessRules.KEY_EXCL_RSN]
                            value_list_1 = [business_rule_id, "N",
                                            datetime.utcnow().strftime('%Y-%m-%d'),
                                            "PRI_SPEC_CD",
                                            "E", "PRI_SPEC_CD"]
                            for data in column_list_new:
                                for key, value in data.items():
                                    key_list_1.append(key)
                                    value_list_1.append(value)
                            key_list = ','.join(key_list_1)
                            value_list = "','".join(value_list_1)
                            rule_value = {}
                            for idx, value in enumerate(key_list_1):
                                rule_value[value] = value_list_1[idx]
                            rule_value = json.dumps(rule_value)
                            insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                            create_rule_query = business_rules_queries.create_rule_query.format(
                                table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                                insert_clause=insert_clause)
                            log.debug("create rule query:\n%s", create_rule_query)
                            try:
                                self.db_obj.raw_query(
                                    create_rule_query, auto_commit=False)
                            except Exception as err:
                                raise Exception(
                                    "Record is already present in alignment_exclusion table for customer_type "
                                    "prescriber and attribute_type speciality_list") from err
                            approval_request_query = business_rules_queries.insert_rule_query.format(
                                rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                                rule_id=business_rule_id,
                                rule_value=rule_value,
                                userid=userid, roleid=roleid,
                                request_date=datetime.strftime(
                                    datetime.utcnow(),
                                    "%Y-%m-%d %H:%M:%S"))
                            log.debug(
                                "Query to send request for approval : %s", approval_request_query)
                            self.db_obj.raw_query(approval_request_query, auto_commit=False)

                if customer_type.lower() == app_constants.BusinessRules.KEY_ACCOUNT:
                    if attribute_type_account_active_flag != True \
                            and len(attribute_type_file_name_pattern) == 0 \
                            and len(attribute_type_entity_classification_list) == 0:
                        raise Exception(
                            "Please fill atleast one in attribute based exclusuion category")
                    if attribute_type_account_active_flag:
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "ACNT_STAT", "ACTIVE", "ACNT_STAT", "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type account and "
                                "attribute_type active_flag") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if attribute_type_account_active_flag == False:
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "ACNT_STAT", "INACTIVE", "ACNT_STAT", "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type account and "
                                "attribute_type active_flag") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if len(attribute_type_file_name_pattern):
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_ATTR_TYPE,
                                      app_constants.BusinessRules.KEY_ATTR_VAL,
                                      app_constants.BusinessRules.KEY_EXCL_RSN,
                                      app_constants.BusinessRules.KEY_EXCL_FLG]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d'),
                                        "ACNT_NM",
                                        attribute_type_file_name_pattern,
                                        "ACNT_NM", "E"]
                        for data in common_column_list_exclusuion:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(value)
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_exclusion table for customer_type account and "
                                "attribute_type file_name_pattern") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                    if len(attribute_type_entity_classification_list):
                        business_rule_id = datetime.utcnow().strftime(
                            '%Y%m-%d%H-%M%S-') + str(
                            uuid.uuid4().hex[:8])
                        entity_classification_list = []
                        for entity_classification in attribute_type_entity_classification_list:
                            entity_classification_list.append(
                                {"ATTR_VAL": entity_classification})

                        for i, item in enumerate(entity_classification_list):
                            column_list_new = [
                                {app_constants.BusinessRules.KEY_MKT_NM: market_name},
                                {app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                                {app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                                {app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                                {
                                    app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                                item]
                            key_list_1 = [
                                app_constants.BusinessRules.KEY_RULE_ID,
                                app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                app_constants.BusinessRules.KEY_INSERT_DATE,
                                app_constants.BusinessRules.KEY_ATTR_TYPE,
                                app_constants.BusinessRules.KEY_EXCL_FLG,
                                app_constants.BusinessRules.KEY_EXCL_RSN]
                            value_list_1 = [business_rule_id, "N",
                                            datetime.utcnow().strftime('%Y-%m-%d'),
                                            "COT_CD", "E",
                                            "COT_CD"]
                            for data in column_list_new:
                                for key, value in data.items():
                                    key_list_1.append(key)
                                    value_list_1.append(value)
                            key_list = ','.join(key_list_1)
                            value_list = "','".join(value_list_1)
                            rule_value = {}
                            for idx, value in enumerate(key_list_1):
                                rule_value[key_list_1[idx]] = value_list_1[idx]
                            rule_value = json.dumps(rule_value)
                            insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                            create_rule_query = business_rules_queries.create_rule_query.format(
                                table_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION_TABLE,
                                insert_clause=insert_clause)
                            log.debug("create rule query:\n%s", create_rule_query)
                            try:
                                self.db_obj.raw_query(
                                    create_rule_query, auto_commit=False)
                            except Exception as err:
                                raise Exception(
                                    "Record is already present in alignment_exclusion table for customer_type account "
                                    "and attribute_type entity_classification_list") from err
                            approval_request_query = business_rules_queries.insert_rule_query.format(
                                rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_EXCLUSION,
                                rule_id=business_rule_id,
                                rule_value=rule_value,
                                userid=userid, roleid=roleid,
                                request_date=datetime.strftime(
                                    datetime.utcnow(),
                                    "%Y-%m-%d %H:%M:%S"))
                            log.debug(
                                "Query to send request for approval : %s", approval_request_query)
                            self.db_obj.raw_query(approval_request_query, auto_commit=False)

            if customer_overrides_flag and override_upload == "false" and inclusion_upload == "false":
                if customer_inclusion_list:
                    business_rule_id = datetime.utcnow().strftime(
                        '%Y%m-%d%H-%M%S-') + str(
                        uuid.uuid4().hex[:8])
                    for i, item in enumerate(customer_inclusion_list):
                        column_list_new = [{app_constants.BusinessRules.KEY_MKT_NM: market_name},
                                           {
                                               app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                                           {
                                               app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                                           {
                                               app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                                           {
                                               app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                                           item]
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_TERR_ID,
                                      app_constants.BusinessRules.KEY_INCL_EXCL_FLG,
                                      app_constants.BusinessRules.KEY_ALIGT_SPLT_PCT]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'), "",
                                        "I", "1"]
                        for data in column_list_new:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(str(value))
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)

                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_override table for customer_inclusion_list") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

                if customer_overrides_list:
                    business_rule_id = datetime.utcnow().strftime(
                        '%Y%m-%d%H-%M%S-') + str(
                        uuid.uuid4().hex[:8])
                    for i, item in enumerate(customer_overrides_list):
                        column_list_new = [{app_constants.BusinessRules.KEY_MKT_NM: market_name},
                                           {
                                               app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                                           {
                                               app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                                           {
                                               app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                                           {
                                               app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                                           item]
                        key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                      app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                      app_constants.BusinessRules.KEY_INSERT_DATE,
                                      app_constants.BusinessRules.KEY_INCL_EXCL_FLG,
                                      app_constants.BusinessRules.KEY_EXCL_RSN]
                        value_list_1 = [business_rule_id, "N",
                                        datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'),
                                        "I", "Inclusion"]
                        for data in column_list_new:
                            for key, value in data.items():
                                key_list_1.append(key)
                                value_list_1.append(str(value))
                        key_list = ','.join(key_list_1)
                        value_list = "','".join(value_list_1)
                        rule_value = {}
                        for idx, value in enumerate(key_list_1):
                            rule_value[value] = value_list_1[idx]
                        rule_value = json.dumps(rule_value)
                        insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                        create_rule_query = business_rules_queries.create_rule_query.format(
                            table_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE_TABLE,
                            insert_clause=insert_clause)
                        log.debug("create rule query:\n%s", create_rule_query)
                        try:
                            self.db_obj.raw_query(
                                create_rule_query, auto_commit=False)
                        except Exception as err:
                            raise Exception(
                                "Record is already present in alignment_override table for customer_overrides_list") from err
                        approval_request_query = business_rules_queries.insert_rule_query.format(
                            rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE,
                            rule_id=business_rule_id,
                            rule_value=rule_value,
                            userid=userid, roleid=roleid,
                            request_date=datetime.strftime(datetime.utcnow(),
                                                           "%Y-%m-%d %H:%M:%S"))
                        log.debug(
                            "Query to send request for approval : %s", approval_request_query)
                        self.db_obj.raw_query(approval_request_query, auto_commit=False)

            if inclusion_upload == "true":
                query = business_rules_queries.business_rule_s3_path.format(
                        rule_category_name=app_constants.ApprovalRequests.RULE_CATEGORY_ALIGNMENT_CUSTOMER_INCLUSION_EXTERNAL)
                log.debug(f"""Query to fetch S3 path for saving rule output file : {query}""")
                result = self.db_obj.raw_query(query)
                active_flag = result[0]['active_flag']
                s3_path = result[0]['s3_path']
                if active_flag == "N":
                    raise HTTPException(
                        status_code=500,
                        detail="Active flag is set to N. Please set it to Y to fetch S3 path")

                if s3_path == "" or s3_path is None:
                    raise HTTPException(
                        status_code=500,
                        detail="s3_path is empty. Please configure S3 path to save rule file")
                
                s3_path_list = s3_path.split("/")
                bucket = s3_path_list[2]

                prefix = s3_path_list[3:]
                prefix = '/'.join(prefix)

                file_content = BytesIO(
                    uploaded_file_for_inclusion.file.read())
                data = pd.read_csv(file_content, delimiter=',')
                external_file_data = data
                external_file_data.to_csv('alignment_inclusion_external_file.csv', sep = '|', index = None)
                external_file_data.columns= external_file_data.columns.str.upper()

                s3_resource = boto3.resource('s3')
                file_timestamp=datetime.strftime(datetime.utcnow(),"%Y-%m-%d %H:%M:%S")

                try:
                    s3_resource.meta.client.upload_file('alignment_inclusion_external_file.csv', bucket , prefix + 'Alignment_Inclusion_External_File_' + file_timestamp)
                    log.debug("The External file is uploaded in AWS S3 Location: s3://" + bucket + prefix + 'Alignment_Inclusion_External_File_' + file_timestamp)
                except:
                    print("Error occured while uploading file in AWS S3 Location!")
                    raise HTTPException(
                        status_code=500,
                        detail="Error occured while uploading file in AWS S3 Location!")
                
                header_content = []
                for column in data.columns:
                    header_content.append(
                        {app_constants.CommonConstants.KEY_KEY: column,
                         app_constants.CommonConstants.KEY_LABEL: column})
                    data[column] = data[column].apply(str)
                preview_data = data.to_dict(orient="records")
                for i, item in enumerate(preview_data):
                    business_rule_id = datetime.utcnow().strftime(
                        '%Y%m-%d%H-%M%S-') + str(
                        uuid.uuid4().hex[:8])
                    column_list_new = [{app_constants.BusinessRules.KEY_MKT_NM: market_name},
                                       {
                                           app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                                       {app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                                       {
                                           app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                                       {
                                           app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                                       item]
                    key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                  app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                  app_constants.BusinessRules.KEY_INSERT_DATE,
                                  app_constants.BusinessRules.KEY_TERR_ID,
                                  app_constants.BusinessRules.KEY_INCL_EXCL_FLG,
                                  app_constants.BusinessRules.KEY_ALIGT_SPLT_PCT]
                    value_list_1 = [business_rule_id, "N",
                                    datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'), "",
                                    "I",
                                    "1"]
                    for data in column_list_new:
                        for key, value in data.items():
                            key_list_1.append(key)
                            value_list_1.append(str(value))
                    key_list = ','.join(key_list_1)
                    value_list = "','".join(value_list_1)
                    rule_value = {}
                    for idx, value in enumerate(key_list_1):
                        rule_value[value] = value_list_1[idx]
                    rule_value = json.dumps(rule_value)
                    insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                    create_rule_query = business_rules_queries.create_rule_query.format(
                        table_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE_TABLE,
                        insert_clause=insert_clause)
                    log.debug("create rule query:\n%s", create_rule_query)
                    try:
                        self.db_obj.raw_query(
                            create_rule_query, auto_commit=False)
                    except Exception as err:
                        raise Exception
                    approval_request_query = business_rules_queries.insert_rule_query.format(
                        rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE,
                        rule_id=business_rule_id,
                        rule_value=rule_value,
                        userid=userid, roleid=roleid,
                        request_date=datetime.strftime(datetime.utcnow(),
                                                       "%Y-%m-%d %H:%M:%S"))
                    log.debug(
                        "Query to send request for approval : %s", approval_request_query)
                    self.db_obj.raw_query(approval_request_query, auto_commit=False)

            if override_upload == "true":
                query = business_rules_queries.business_rule_s3_path.format(
                        rule_category_name=app_constants.ApprovalRequests.RULE_CATEGORY_ALIGNMENT_CUSTOMER_OVERRIDE_EXTERNAL)
                log.debug(f"""Query to fetch S3 path for saving rule output file : {query}""")
                result = self.db_obj.raw_query(query)
                active_flag = result[0]['active_flag']
                s3_path = result[0]['s3_path']
                if active_flag == "N":
                    raise HTTPException(
                        status_code=500,
                        detail="Active flag is set to N. Please set it to Y to fetch S3 path")

                if s3_path == "" or s3_path is None:
                    raise HTTPException(
                        status_code=500,
                        detail="s3_path is empty. Please configure S3 path to save rule file")
                
                s3_path_list = s3_path.split("/")
                bucket = s3_path_list[2]

                prefix = s3_path_list[3:]
                prefix = '/'.join(prefix)
                
                file_content = BytesIO(
                    uploaded_file_for_overrides.file.read())
                data = pd.read_csv(file_content, delimiter=',')
                external_file_data = data
                external_file_data.to_csv('alignment_override_external_file.csv', sep = '|', index = None)
                external_file_data.columns= external_file_data.columns.str.upper()

                s3_resource = boto3.resource('s3')
                file_timestamp=datetime.strftime(datetime.utcnow(),"%Y-%m-%d %H:%M:%S")
                
                try:
                    s3_resource.meta.client.upload_file('alignment_override_external_file.csv', bucket , prefix + 'Alignment_Override_External_File_' + file_timestamp)
                    log.debug("The External file is uploaded in AWS S3 Location: s3://" + bucket + prefix + "Alignment_Override_External_File_" + file_timestamp)
                except:
                    print("Error occured while uploading file in AWS S3 Location!")
                    raise HTTPException(
                        status_code=500,
                        detail="Error occured while uploading file in AWS S3 Location!")
                
                header_content = []
                for column in data.columns:
                    header_content.append(
                        {app_constants.CommonConstants.KEY_KEY: column,
                         app_constants.CommonConstants.KEY_LABEL: column})
                    data[column] = data[column].apply(str)
                preview_data = data.to_dict(orient="records")
                for i, item in enumerate(preview_data):
                    business_rule_id = datetime.utcnow().strftime(
                        '%Y%m-%d%H-%M%S-') + str(
                        uuid.uuid4().hex[:8])
                    column_list_new = [{app_constants.BusinessRules.KEY_MKT_NM: market_name},
                                       {
                                           app_constants.BusinessRules.KEY_SLS_FRC_NM: salesforce_name},
                                       {app_constants.BusinessRules.KEY_PTY_TYPE: customer_type},
                                       {
                                           app_constants.BusinessRules.KEY_ALIGT_QTR: alignment_quarter},
                                       {
                                           app_constants.BusinessRules.KEY_IS_FROZEN_FLG: ic_frozen_alignment_flag},
                                       item]

                    key_list_1 = [app_constants.BusinessRules.KEY_RULE_ID,
                                  app_constants.BusinessRules.KEY_ACTIVE_FLAG,
                                  app_constants.BusinessRules.KEY_INSERT_DATE,
                                  app_constants.BusinessRules.KEY_INCL_EXCL_FLG,
                                  app_constants.BusinessRules.KEY_EXCL_RSN]
                    value_list_1 = [business_rule_id, "N",
                                    datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'), "I",
                                    "Inclusion"]
                    for data in column_list_new:
                        for key, value in data.items():
                            key_list_1.append(key)
                            value_list_1.append(str(value))
                    key_list = ','.join(key_list_1)
                    value_list = "','".join(value_list_1)
                    rule_value = {}
                    for idx, value in enumerate(key_list_1):
                        rule_value[value] = value_list_1[idx]
                    rule_value = json.dumps(rule_value)
                    insert_clause = "(" + key_list + ")" + " values " + "(" + "'" + value_list + "'" + ")"
                    create_rule_query = business_rules_queries.create_rule_query.format(
                        table_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE_TABLE,
                        insert_clause=insert_clause)
                    log.debug("create rule query:\n%s", create_rule_query)
                    try:
                        self.db_obj.raw_query(create_rule_query, auto_commit=False)
                    except Exception as err:
                        raise Exception
                    approval_request_query = business_rules_queries.insert_rule_query.format(
                        rule_category_name=app_constants.BusinessRules.KEY_ALIGNMENT_OVERRIDE,
                        rule_id=business_rule_id,
                        rule_value=rule_value,
                        userid=userid, roleid=roleid,
                        request_date=datetime.strftime(datetime.utcnow(),
                                                       "%Y-%m-%d %H:%M:%S"))
                    log.debug(
                        "Query to send request for approval : %s", approval_request_query)
                    self.db_obj.raw_query(approval_request_query, auto_commit=False)

            rule_category_value = "Alignment"
            user_id_email_query = approval_requests_queries.requested_by_user_id_email_query.format(
                userid=userid)
            user_id_email = self.db_obj.raw_query(
                user_id_email_query)
            user_id_email = user_id_email[0][
                "email_id"]

            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + " --json_file_path " + config_dir_path + "/email_notification_configurations.json" + \
                              " --username " + '"' + user_id_email + '"' + " --rule_category " + '"' + rule_category_value + '"' + " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            with open(config_dir_path + "/email_notification_configurations.json") as f:
                data = json.load(f)
                data = data['NotificationUtility']
                ops_user_id_email = data["OPS_USER_MAIL_ID"]
            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + " --json_file_path " + config_dir_path + "/email_notification_configurations.json" + \
                              " --username " + '"' + ops_user_id_email + '"' + " --rule_created_by " + '"' + user_id_email + '"' + " --rule_category " + '"' + rule_category_value + '"' + " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            log.debug("data inserted in rule table for request approval")

            return []
        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            self.db_obj.db.commit()
            del self.db_obj

    def get_segmentation_form(self, mkt_nm, cust_type, seg_nm, seg_type, role_id):
        """
        Method to fetch segmentation form which has all the required UI fields
        :return: Segmentation form details
        """
        try:
            log.info("Fetching the segmentation form data")

            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch lookback time period list. Please contact admin")
            # s3_staging_dir = config_details['athena_s3_staging_dir']
            # user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            # boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            # log.info("Getting lookback time period list...")
            # get_lookback_time_period_list_query = business_rules_queries.GET_LOOKBACK_TIME_PERIOD_LIST_QUERY.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            # seg_nm = seg_nm, seg_type = seg_type)
            # log.info("Query to fetch lookback time period list: %s", get_lookback_time_period_list_query)
            # lookback_time_period_list = wr.athena.read_sql_query(sql=get_lookback_time_period_list_query,
            #                                        database=app_configurations.BUSINESS_RULES_STG_DB,
            #                                        ctas_approach=False,
            #                                        s3_output=s3_staging_dir,
            #                                        boto3_session=boto_session)
            # lookback_time_period_list = json.loads(lookback_time_period_list.to_json(orient="records"))
            # print(lookback_time_period_list)
            # lookback_time_period_list = lookback_time_period_list[0]["look_back_tp_val"]
            # print(lookback_time_period_list)
            
            # log.info("Lookback time period value: %s", lookback_time_period_list)

            segmentation_form = app_constants.BusinessRulesForms.segmentation_form(
                market_list=list(),
                customer_types=list(),
                segment_name_list=list(),
                segment_types=list(),
                product_group_list=list(),
                add_product_list=list(),
                remove_product_list=list(),
                account_table_metric_columns=list(), lookback_time_period_list = list())

            log.info("Adding some default values to the form...")
            data = {
                BusinessRulesForms.ZERO_DEC_PERC_KEY: BusinessRulesForms.ZERO_DEC_PERC_DEFAULT_VALUE,
                BusinessRulesForms.METRIC_TBL_NM_KEY: BusinessRulesForms.ACCOUNT_TABLE_NAME,
                BusinessRulesForms.METRIC_COL_NM_KEY: BusinessRulesForms.METRIC_COL_NM_VAL,
                BusinessRulesForms.LOOK_BACK_TP_BCKT_KEY: BusinessRulesForms.LOOK_BACK_TP_BCKT_VAL,
                BusinessRulesForms.SRC_ID_NAME_KEY: BusinessRulesForms.SRC_ID_NAME_VAL
            }
            segmentation_form[BusinessRulesForms.DATA_KEY] = data

            log.info("Segmentation JSON form: %s", segmentation_form)

            return segmentation_form

        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj

    def get_segmentation_market_list(self, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch Market list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Market list...")
            get_market_list_query = business_rules_queries.GET_MARKET_LIST_QUERY
            log.info("Query to fetch market list: %s", get_market_list_query)
            market_list = wr.athena.read_sql_query(sql=get_market_list_query,
                                                   database=app_configurations.BUSINESS_RULES_STG_DB,
                                                   ctas_approach=False,
                                                   max_cache_seconds=900,
                                                   max_local_cache_entries=200,
                                                   max_cache_query_inspections = 50,
                                                   s3_output=s3_staging_dir,
                                                   boto3_session=boto_session)
            market_list = json.loads(market_list.to_json(orient="records"))

            log.info("Market list: %s", market_list)
            return market_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_segmentation_customer_types(self, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch customer types. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Customer types...")
            get_customer_types_query = business_rules_queries.GET_CUSTOMER_TYPES_QUERY
            log.info("Query to fetch customer types : %s", get_customer_types_query)
            customer_types = wr.athena.read_sql_query(sql=get_customer_types_query,
                                                      database=app_configurations.BUSINESS_RULES_STG_DB,
                                                      ctas_approach=False,
                                                      max_cache_seconds=900,
                                                      max_local_cache_entries=200,
                                                      max_cache_query_inspections = 50,
                                                      s3_output=s3_staging_dir,
                                                      boto3_session=boto_session)
            customer_types = json.loads(customer_types.to_json(orient="records"))
            log.info("Customer Types: %s", customer_types)

            return customer_types
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error
        except ClientError as err:
            client_error(err)
        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_segment_name_list(self, mkt_nm, cust_type, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch segment names. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Segment Names...")
            get_segment_names_query = business_rules_queries.GET_SEGMENT_NAMES_QUERY.format(mkt_nm=mkt_nm, cust_type=cust_type)
            log.info("Query to fetch segment names types : %s", get_segment_names_query)
            result = wr.athena.read_sql_query(sql=get_segment_names_query,
                                              database=app_configurations.BUSINESS_RULES_STG_DB,
                                              ctas_approach=False,
                                              max_cache_seconds=900,
                                              max_local_cache_entries=200,
                                              max_cache_query_inspections = 50,
                                              s3_output=s3_staging_dir, boto3_session=boto_session)
            result = json.loads(result.to_json(orient="records"))

            segment_name_list = {}
            for i in result:
                if i[BusinessRulesForms.COL_CUST_TYPE] in segment_name_list.keys():
                    if i[BusinessRulesForms.COL_MKT_NM] in segment_name_list[
                        i[BusinessRulesForms.COL_CUST_TYPE]].keys():
                        segment_name_list[i[BusinessRulesForms.COL_CUST_TYPE]][
                            i[BusinessRulesForms.COL_MKT_NM]].append(
                            {BusinessRulesForms.BIND_VALUE_KEY: i[BusinessRulesForms.COL_SEG_NM],
                             BusinessRulesForms.BIND_LABEL_KEY: i[BusinessRulesForms.COL_SEG_NM],
                             BusinessRulesForms.DEPEND_ON_KEY: BusinessRulesForms.COL_SEG_TYPE,
                             BusinessRulesForms.DEFAULT_VALUE_KEY: i[
                                 BusinessRulesForms.COL_SEG_TYPE]})
                    else:
                        segment_name_list[i[BusinessRulesForms.COL_CUST_TYPE]][
                            i[BusinessRulesForms.COL_MKT_NM]] = [
                            {BusinessRulesForms.BIND_VALUE_KEY: i[
                                BusinessRulesForms.COL_SEG_NM],
                             BusinessRulesForms.BIND_LABEL_KEY: i[
                                 BusinessRulesForms.COL_SEG_NM],
                             BusinessRulesForms.DEPEND_ON_KEY: BusinessRulesForms.COL_SEG_TYPE,
                             BusinessRulesForms.DEFAULT_VALUE_KEY: i[
                                 BusinessRulesForms.COL_SEG_TYPE]}]
                else:
                    segment_name_list[i[BusinessRulesForms.COL_CUST_TYPE]] = {
                        i[BusinessRulesForms.COL_MKT_NM]: [
                            {BusinessRulesForms.BIND_VALUE_KEY: i[
                                BusinessRulesForms.COL_SEG_NM],
                             BusinessRulesForms.BIND_LABEL_KEY: i[
                                 BusinessRulesForms.COL_SEG_NM],
                             BusinessRulesForms.DEPEND_ON_KEY: BusinessRulesForms.COL_SEG_TYPE,
                             BusinessRulesForms.DEFAULT_VALUE_KEY: i[
                                 BusinessRulesForms.COL_SEG_TYPE]}]}
            log.info("Segment Names: %s", segment_name_list)

            return segment_name_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error
        except ClientError as err:
            client_error(err)
        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_segment_types(self, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch segment types. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Segment Types...")
            get_segment_types_query = business_rules_queries.GET_SEGMENT_TYPES_QUERY
            log.info("Query to fetch segment types : %s", get_segment_types_query)
            segment_types = wr.athena.read_sql_query(sql=get_segment_types_query,
                                                     database=app_configurations.BUSINESS_RULES_STG_DB,
                                                     ctas_approach=False,
                                                     max_cache_seconds=900,
                                                     max_local_cache_entries=200,
                                                     max_cache_query_inspections = 50,
                                                     s3_output=s3_staging_dir,
                                                     boto3_session=boto_session)
            segment_types = json.loads(segment_types.to_json(orient="records"))
            log.info("Segment Types: %s", segment_types)

            return segment_types
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_segmentation_product_groups(self, mkt_nm, cust_type, seg_nm, seg_type,role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product groups. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Product group names...")
            get_product_group_list_query = business_rules_queries.GET_PRODUCT_GROUP_LIST_QUERY.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            seg_nm = seg_nm, seg_type = seg_type)
            log.info("Query to fetch product group name : %s", get_product_group_list_query)
            product_group_list = wr.athena.read_sql_query(sql=get_product_group_list_query,
                                                          database=app_configurations.BUSINESS_RULES_DW_DB,
                                                          ctas_approach=False,
                                                          max_cache_seconds=900,
                                                          max_local_cache_entries=200,
                                                          max_cache_query_inspections = 50,
                                                          s3_output=s3_staging_dir,
                                                          boto3_session=boto_session)
            product_group_list = json.loads(product_group_list.to_json(orient="records"))
            log.info("Product group names: %s", product_group_list)

            return product_group_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

#         finally:
#             del self.audit_obj
#             try:
#                 del boto_session
#             except (UnboundLocalError, NameError):
#                 pass

    def get_segmentation_product_groups_dropdown(self, mkt_nm, cust_type, seg_nm, seg_type,role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product groups. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            log.info("Getting Product group names for dropdown...")
            get_product_group_list_query_dropdown = business_rules_queries.GET_PRODUCT_GROUP_LIST_QUERY_DROPDOWN.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            seg_nm = seg_nm, seg_type = seg_type)
            log.info("Query to fetch product group name : %s", get_product_group_list_query_dropdown)
            product_group_list_dropdown = wr.athena.read_sql_query(sql=get_product_group_list_query_dropdown,
                                                          database=app_configurations.BUSINESS_RULES_DW_DB,
                                                          ctas_approach=False,
                                                          max_cache_seconds=900,
                                                          max_local_cache_entries=200,
                                                          max_cache_query_inspections = 50,
                                                          s3_output=s3_staging_dir,
                                                          boto3_session=boto_session)
            product_group_list_dropdown = json.loads(product_group_list_dropdown.to_json(orient="records"))
            log.info("Product group names for dropdown: %s", product_group_list_dropdown)

            return product_group_list_dropdown
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

#         finally:
#             del self.audit_obj
#             try:
#                 del boto_session
#             except (UnboundLocalError, NameError):
#                 pass
              
    def get_segmentation_product_list(self, mkt_nm, cust_type, seg_nm, seg_type, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product groups. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            log.info("Getting Product group list...")
            get_product_group_complete_list_query = business_rules_queries.GET_PRODUCT_GROUP_COMPLETE_LIST_QUERY.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            seg_nm = seg_nm, seg_type = seg_type)
            log.info("Query to fetch product group name : %s", get_product_group_complete_list_query)
            product_group_complete_list = wr.athena.read_sql_query(sql=get_product_group_complete_list_query,
                                                          database=app_configurations.BUSINESS_RULES_DW_DB,
                                                          ctas_approach=False,
                                                          max_cache_seconds=900,
                                                          max_local_cache_entries=200,
                                                          max_cache_query_inspections = 50,
                                                          s3_output=s3_staging_dir,
                                                          boto3_session=boto_session)
            product_group_complete_list = json.loads(product_group_complete_list.to_json(orient="records"))
            log.info("Product group names for dropdown: %s", product_group_complete_list)

            return product_group_complete_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_segmentation_product_addition_list(self, mkt_nm, cust_type, seg_nm, seg_type, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Product list for Add product dropdown...")
            get_add_product_list_query = business_rules_queries.GET_ADD_PRODUCT_LIST_QUERY.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            seg_nm = seg_nm, seg_type = seg_type)
            log.info("Query to fetch product list for Add product dropdown : %s",
                     get_add_product_list_query)
            add_product_list_query_result = wr.athena.read_sql_query(sql=get_add_product_list_query,
                                                                     database=app_configurations.BUSINESS_RULES_DW_DB,
                                                                     ctas_approach=False,
                                                                     max_cache_seconds=900,
                                                                     max_local_cache_entries=200,
                                                                     max_cache_query_inspections = 50,
                                                                     s3_output=s3_staging_dir,
                                                                     boto3_session=boto_session)
            add_product_list_query_result = json.loads(
                add_product_list_query_result.to_json(orient="records"))

            add_product_list = {}
            if add_product_list_query_result:
                sorted_prods = sorted(add_product_list_query_result,
                                      key=itemgetter(
                                          BusinessRulesForms.COL_MKT_NM))
                for key, value in groupby(sorted_prods, key=itemgetter(
                        BusinessRulesForms.COL_MKT_NM)):
                    prod_list = [{BusinessRulesForms.BIND_LABEL_KEY: i[
                        BusinessRulesForms.BIND_LABEL_KEY],
                                  BusinessRulesForms.BIND_VALUE_KEY: i[
                                      BusinessRulesForms.BIND_VALUE_KEY]} for i
                                 in
                                 list(value)]
                    add_product_list[key] = prod_list
            log.info("Product list for Add product dropdown: %s", add_product_list)

            return add_product_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_segmentation_product_removal_list(self, mkt_nm, cust_type, seg_nm, seg_type, prod_grp_nm, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Product list for Remove product dropdown...")
            get_remove_product_list_query = business_rules_queries.GET_REMOVE_PRODUCT_LIST_QUERY.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            seg_nm = seg_nm, seg_type = seg_type, prod_grp_nm = prod_grp_nm)
            log.info("Query to fetch product list for Remove product dropdown : %s",
                     get_remove_product_list_query)
            remove_product_list_query_result = wr.athena.read_sql_query(
                sql=get_remove_product_list_query,
                database=app_configurations.BUSINESS_RULES_DW_DB,
                ctas_approach=False,
                max_cache_seconds=900,
                max_local_cache_entries=200,
                max_cache_query_inspections = 50,
                s3_output=s3_staging_dir,
                boto3_session=boto_session)
            remove_product_list_query_result = json.loads(
                remove_product_list_query_result.to_json(orient="records"))

            remove_product_list = {}
            if remove_product_list_query_result:
                sorted_prods = sorted(remove_product_list_query_result, key=itemgetter(BusinessRulesForms.COL_PROD_GRP_NM))
                for key, value in groupby(sorted_prods, key=itemgetter(BusinessRulesForms.COL_PROD_GRP_NM)):
                    prod_list = []
                    for i in list(value):
                        temp_dict = {BusinessRulesForms.BIND_LABEL_KEY: i[BusinessRulesForms.BIND_LABEL_KEY], BusinessRulesForms.BIND_VALUE_KEY: i[BusinessRulesForms.BIND_VALUE_KEY]}
                        if temp_dict not in prod_list:
                            prod_list.append(temp_dict)
                    remove_product_list[key] = prod_list
            log.info("Product list for Remove product dropdown: %s", remove_product_list)

            return remove_product_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass
              
    def get_segmentation_lookback_tp(self, mkt_nm, cust_type, seg_nm, seg_type, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting lookback time period list...")
            get_lookback_time_period_list_query = business_rules_queries.GET_LOOKBACK_TIME_PERIOD_LIST_QUERY.format(mkt_nm = mkt_nm, cust_type = cust_type, 
            seg_nm = seg_nm, seg_type = seg_type)
            log.info("Query to fetch lookback time period list: %s", get_lookback_time_period_list_query)
            lookback_time_period_list = wr.athena.read_sql_query(sql=get_lookback_time_period_list_query,
                                                   database=app_configurations.BUSINESS_RULES_STG_DB,
                                                   ctas_approach=False,
                                                   s3_output=s3_staging_dir,
                                                   boto3_session=boto_session)
            lookback_time_period_list = json.loads(lookback_time_period_list.to_json(orient="records"))

            lookback_time_period_list = lookback_time_period_list[0]['look_back_tp_val']

            log.info("Lookback time period value: %s", lookback_time_period_list)

            return lookback_time_period_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass


    def get_segmentation_metric_columns(self, role_id):
        try:
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch metric column list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting metric column list...")
            get_account_table_metric_columns_query = business_rules_queries.GET_ACCOUNT_TABLE_METRIC_COLUMNS_QUERY
            log.info("Query to fetch metric columns: %s", get_account_table_metric_columns_query)
            metric_columns = wr.athena.read_sql_query(sql=get_account_table_metric_columns_query,
                                                      database=app_configurations.BUSINESS_RULES_DW_DB,
                                                      ctas_approach=False,
                                                      max_cache_seconds=900,
                                                      max_local_cache_entries=200,
                                                      max_cache_query_inspections = 50,
                                                      s3_output=s3_staging_dir,
                                                      boto3_session=boto_session)
            #log.debug("Metric Columns before df are: ", metric_columns)
            metric_columns_df = pd.DataFrame(metric_columns)
            #metric_columns = json.loads(metric_columns.to_json(orient="records"))
            #log.debug("Metric Columns are: ", metric_columns_df)
            metric_columns_list = []
            metric_columns_list = [{"bind_value": col,"bind_label": col} for col in metric_columns_df]
            #log.debug("Metric Columns List is: ", metric_columns_list)
            log.debug("Fetched metric columns successfully")
            return metric_columns_list

        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def create_segmentation_business_rule(self, userid, roleid, pageid,
                                          segmentation_details: SegmentationRuleDetails,
                                          uploaded_file):
        """
        :param uploaded_file:
        :param userid: username of the logged in user
        :param roleid: id of the role assigned to that user
        :param pageid: id of the page for which user has access
        :param segmentation_details: input parameters from UI
        :return: status of rule created
        """
        try:
            log.info("Starting function to create segmentation rule...")
            external_file_data = None
            log.info("Checking the external file upload...")
            if segmentation_details.input_type == "external_file" and uploaded_file is not None:
                log.info("User uploaded an external file...")
                log.debug("Reading the file details...")
                file_content = BytesIO(uploaded_file.file.read())
                #external_file_data = pd.read_csv(file_content,sep=';',encoding='utf-8')
                #external_file_data = pd.read_csv(file_content, sep="\s*[,]\s*", encoding='utf-8', skipinitialspace=True)
                
                encodings = ["utf-8-sig", "utf-8", "utf-16-be", "utf-16", "utf-32-be", "utf-32", "cp1252", "iso-8859-1", "latin1"]

                external_file_data=""
                current_encoding = ""
                in_loop = True

                while(in_loop):
                  try:
                    for enc in encodings:
                      current_encoding = enc
                      external_file_data = pd.read_csv(file_content, sep="\s*[,]\s*", encoding= enc , skipinitialspace=True)
                      in_loop = False
                      break
                  except Exception as e:
                    encodings.remove(current_encoding)
                    print("encoding : " , current_encoding)
                    print(e)
                    if len(encodings) == 0:
                      break
                    continue
                
                external_file_data.to_csv('segmentation_external_file.csv', sep='|', index = None)
                external_file_data.columns= external_file_data.columns.str.lower()

                s3_resource = boto3.resource('s3')
                file_timestamp=datetime.strftime(datetime.utcnow(),"%Y-%m-%d %H:%M:%S")
                
                query = business_rules_queries.business_rule_s3_path.format(
                    rule_category_name=app_constants.ApprovalRequests.RULE_CATEGORY_SEGMENTATION_EXTERNAL)
                log.debug(f"""Query to fetch S3 path for saving External file : {query}""")
                result = self.db_obj.raw_query(query)
                active_flag = result[0]['active_flag']
                s3_path = result[0]['s3_path']
                if active_flag == "N":
                    raise HTTPException(
                        status_code=500,
                        detail="Active flag is set to N. Please set it to Y to fetch S3 path")

                if s3_path == "" or s3_path is None:
                    raise HTTPException(
                        status_code=500,
                        detail="s3_path is empty. Please configure S3 path to save rule file")
                
                s3_path_list = s3_path.split("/")
                bucket = s3_path_list[2]

                prefix = s3_path_list[3:]
                prefix = '/'.join(prefix)
                
                try:
                    s3_resource.meta.client.upload_file('segmentation_external_file.csv', bucket , prefix +'Segmentation_External_File_' + file_timestamp)
                    log.debug("The External file is uploaded in AWS S3 Location: s3://" + bucket + prefix +"Segmentation_External_File_" + file_timestamp)
                except:
                    print("Error occured while uploading file in AWS S3 Location!")
                    raise HTTPException(
                        status_code=500,
                        detail="Error occured while uploading file in AWS S3 Location!")

                column_names = []
                for each in external_file_data.columns:
                    column_names.append(each)
                file_cust_id = column_names[0]
                file_decile = column_names[1]
                if file_cust_id != BusinessRulesForms.COL_CUST_ID and file_decile != BusinessRulesForms.COL_DECILE:
                    raise HTTPException(
                        status_code=500,
                        detail="Please upload a valid file with cust_id, decile as columns.")
                if external_file_data.empty:
                    raise HTTPException(status_code=500,
                                        detail="Please upload a file with at least one record in it.")
                if (external_file_data.dtypes['cust_id'] != 'object' and external_file_data.dtypes['cust_id'] != 'int64') or external_file_data.dtypes['decile'] != 'int64':
                    raise HTTPException(status_code=500,
                                        detail="Please upload a file with cust_id in Varchar and decile column in Integer Format only")

            log.debug("Creating a business rule id...")
            business_rule_id = datetime.utcnow().strftime('%Y%m-%d%H-%M%S-') + str(
                uuid.uuid4().hex[:8])
            log.debug("Business rule id: %s", business_rule_id)

            add_prod_list = segmentation_details.add_prod_list \
                if segmentation_details.add_prod_list \
                   and segmentation_details.add_prod_list != ["null"] else ""
            remove_prod_list = segmentation_details.remove_prod_list \
                if segmentation_details.remove_prod_list \
                   and segmentation_details.remove_prod_list != ["null"] else ""
            final_prod_list = ""

            if segmentation_details.seg_type == 'CALCULATED':
                log.debug("Fetching a Metric Table name if Segment type is CALCULATED...")
                if segmentation_details.metric_col_nm or segmentation_details.metric_col_nm != "":

                    metric_table_name_query = business_rules_queries.metric_table_name_query.format(
                        src_id_nm=segmentation_details.src_id_nm,
                        metric_col_nm=segmentation_details.metric_col_nm,
                        mkt_nm=segmentation_details.mkt_nm
                    )
                    log.debug("Query to fetch metric table name is:\n{}".format(
                        metric_table_name_query))
                    metric_table_name_details = self.db_obj.raw_query(metric_table_name_query)
                    if len(metric_table_name_details) == 0:
                        raise HTTPException(
                            status_code=500,
                            detail="Segementation rule can't be created for the selected combination")
                    segmentation_details.metric_tbl_nm = metric_table_name_details[0][
                        "metric_table"]

                    log.info("Metric Table name: %s", segmentation_details.metric_tbl_nm)

                prod_list = segmentation_details.prod_list.split(" | ")
                segmentation_details.add_prod_list = segmentation_details.add_prod_list if segmentation_details.add_prod_list and segmentation_details.add_prod_list != [
                    "null"] else []
                segmentation_details.remove_prod_list = segmentation_details.remove_prod_list if segmentation_details.remove_prod_list and segmentation_details.remove_prod_list != [
                    "null"] else []

                final_prod_list = list(
                    set(prod_list) | set(segmentation_details.add_prod_list))

                add_prod_list = " | ".join(segmentation_details.add_prod_list)

                remove_prod_list = " | ".join(segmentation_details.remove_prod_list)

                final_prod_list = [i for i in final_prod_list if
                                   i not in segmentation_details.remove_prod_list]
                final_prod_list = " | ".join(final_prod_list)

            segmentation_details.zero_dec_perc = 0 \
                if segmentation_details.zero_dec_perc == '' \
                else segmentation_details.zero_dec_perc
            segmentation_details.look_back_tp_val = 0 \
                if segmentation_details.look_back_tp_val == '' \
                else segmentation_details.look_back_tp_val

            log.debug(f"Prod list {add_prod_list},{remove_prod_list},{final_prod_list}")
            
            if segmentation_details.seg_type == 'CALCULATED':
                segmentation_details.metric_tbl_nm = ''
                segmentation_details.input_type = ''
            elif segmentation_details.seg_type == 'EXTERNAL':
                if segmentation_details.input_type == 'external_file':
                    segmentation_details.look_back_tp_val = ''
                    segmentation_details.look_back_tp_bckt = ''
                    segmentation_details.src_id_nm = ''
                    segmentation_details.metric_tbl_nm = ''
                    segmentation_details.metric_col_nm = ''
                    segmentation_details.fltr_cond = ''
                    segmentation_details.zero_dec_perc = ''
                    segmentation_details.prod_grp_nm = ''
                    segmentation_details.prod_list = ''
                    add_prod_list = ''
                    remove_prod_list = ''
                    final_prod_list = ''
                else:
                    segmentation_details.look_back_tp_val = ''
                    segmentation_details.look_back_tp_bckt = ''
                    segmentation_details.src_id_nm = ''
                    segmentation_details.zero_dec_perc = ''
                    segmentation_details.prod_grp_nm = ''
                    segmentation_details.prod_list = ''
                    add_prod_list = ''
                    remove_prod_list = ''
                    final_prod_list = ''

            add_segmentation_rule_query = business_rules_queries.CREATE_SEGMENTATION_RULE_QUERY.format(
                rule_id=business_rule_id, mkt_nm=segmentation_details.mkt_nm,
                cust_type=segmentation_details.cust_type,
                seg_nm=segmentation_details.seg_nm,
                seg_type=segmentation_details.seg_type,
                look_back_tp_val=segmentation_details.look_back_tp_val,
                look_back_tp_bckt=segmentation_details.look_back_tp_bckt,
                src_id_nm=segmentation_details.src_id_nm,
                metric_tbl_nm=segmentation_details.metric_tbl_nm,
                metric_col_nm=segmentation_details.metric_col_nm,
                fltr_cond=segmentation_details.fltr_cond,
                zero_dec_perc=segmentation_details.zero_dec_perc,
                prod_grp_nm=segmentation_details.prod_grp_nm,
                prod_list=segmentation_details.prod_list,
                add_prod_list=add_prod_list,
                remove_prod_list=remove_prod_list,
                final_prod_list=final_prod_list,
                input_type=segmentation_details.input_type)

            add_segmentation_rule_query = add_segmentation_rule_query.replace(
                "'None'", '').replace("\"None\"", '').replace("None", '')

            log.debug("Query to create a segmentation rule: %s", add_segmentation_rule_query)
            self.db_obj.raw_query(add_segmentation_rule_query, auto_commit=False)
            log.info("Added segmentation details successfully.")

            log.info("Checking the external file upload...")
            if segmentation_details.input_type == "external_file" and uploaded_file is not None:
                external_file_data = external_file_data.astype(str)
                log.info(
                    "Adding the external file details to segmentation table(stg_sao_all_decl_input)...")
                market_name = segmentation_details.mkt_nm
                market_name = BusinessRulesForms.MARKET_NAME_PREP if market_name == BusinessRulesForms.MARKET_NAME_HIV and segmentation_details.seg_nm.lower().startswith(
                    'prep') else market_name
                external_file_data[BusinessRulesForms.COL_MKT_NM] = market_name
                external_file_data[
                    BusinessRulesForms.COL_SEG_NM] = segmentation_details.seg_nm
                external_file_data[BusinessRulesForms.COL_ACTIVE_FLAG] = 'N'
                external_file_data[BusinessRulesForms.COL_INSERT_DATE] = datetime.strftime(datetime.utcnow(), "%Y-%m-%d")

                file_records = [tuple(r) for r in external_file_data.to_numpy()]

                add_segmentation_file_details_query = business_rules_queries.ADD_SEGMENTATION_FILE_DETAILS_QUERY
                self.db_obj.execute_many(add_segmentation_file_details_query,
                                         value_list=file_records)
                log.debug("Added file details to the table successfully.")

            approval_request_query = business_rules_queries.insert_rule_query.format(
                rule_id=business_rule_id,
                rule_category_name=BusinessRulesForms.RULE_CATEGORY_SEGMENTATION,
                rule_value=segmentation_details.json(),
                userid=userid, roleid=roleid,
                request_date=datetime.strftime(datetime.utcnow(),
                                               "%Y-%m-%d %H:%M:%S"))

            log.debug("Query to send request for approval after editing rule : %s",
                      approval_request_query)
            self.db_obj.raw_query(approval_request_query)

            action = app_constants.AuditLogs.ACTION_CREATE_BUSINESS_RULE
            message = app_constants.AuditLogs.MSG_CREATE_BUSINESS_RULE.format(
                business_rule_name=segmentation_details.seg_nm,
                rule_category_name=BusinessRulesForms.RULE_CATEGORY_SEGMENTATION)
            self.audit_obj.save_audit_info(self.db_obj, userid, roleid, pageid,
                                           action, message)

            rule_category_value = "Segmentation"
            user_id_email_query = approval_requests_queries.requested_by_user_id_email_query.format(
                userid=userid)
            user_id_email = self.db_obj.raw_query(
                user_id_email_query)
            user_id_email = user_id_email[0]["email_id"]

            execute_command = "python " + utilities_dir_path + \
                              "/NotificationUtility.py" + " --json_file_path " \
                              + config_dir_path + "/email_notification_configurations.json" + \
                              " --username " + '"' + user_id_email + '"' + " --rule_category " + \
                              '"' + rule_category_value + '"' + \
                              " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            with open(config_dir_path + "/email_notification_configurations.json") as f:
                data = json.load(f)
                data = data['NotificationUtility']
                ops_user_id_email = data["OPS_USER_MAIL_ID"]
            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + \
                              " --json_file_path " + config_dir_path + \
                              "/email_notification_configurations.json" + \
                              " --username " + '"' + ops_user_id_email + '"' + \
                              " --rule_created_by " + '"' + user_id_email + '"' + \
                              " --rule_category " + '"' + rule_category_value + '"' + \
                              " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            log.debug("data inserted in rule table for request approval")
        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except IntegrityError as error:
            log.error(error)
            message = "Rule with same details already exists."
            raise HTTPException(status_code=500, detail=message) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_payment_types(self, role_id):
        """
        Method to fetch values for Payment type dropdown
        :return: process frequency list
        """
        try:
            log.debug("Fetching payment types")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch payment types. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            get_payment_types_query = business_rules_queries.GET_PAYMENT_TYPES_QUERY
            log.debug("Query to fetch payment types is:\n{}".format(get_payment_types_query))
            payment_types = wr.athena.read_sql_query(sql=get_payment_types_query,
                                                     database=app_configurations.BUSINESS_RULES_DW_DB,
                                                     ctas_approach=False,
                                                     s3_output=s3_staging_dir,
                                                     boto3_session=boto_session)
            payment_types = json.loads(payment_types.to_json(orient="records"))
            log.debug("Fetched payment types successfully")
            return payment_types
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_hbv_lkp_bck_value(self, role_id):
        """
            Function to fetch the HBV lookback value
        :param role_id: Role Id
        :return: HBV lookback value
        """
        try:
            log.debug("Fetching the HBV lookback value")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch HBV lookback value. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_hbv_prep_lkp_bck_query = business_rules_queries.GET_HBV_LOOK_BACK_PERIOD_QUERY
            log.debug("Query to fetch HBV lookback value is:\n{}".format(
                get_hbv_prep_lkp_bck_query))
            hbv_lkp_bck_value = wr.athena.read_sql_query(sql=get_hbv_prep_lkp_bck_query,
                                                         database=app_configurations.BUSINESS_RULES_STG_DB,
                                                         ctas_approach=False,
                                                         s3_output=s3_staging_dir,
                                                         boto3_session=boto_session)
            hbv_lkp_bck_value = json.loads(hbv_lkp_bck_value.to_json(orient="records"))[0][
                'PARM_VAL_1']
            hbv_lkp_bck_value = str(hbv_lkp_bck_value).strip('-')
            log.debug("Fetched HBV lookback value successfully")
            return hbv_lkp_bck_value

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_hbv_lkp_fwd_value(self, role_id):
        """
            Function to fetch the HBV lookup forward value
        :param role_id: Role Id
        :return: HBV lookup forward value
        """
        try:
            log.debug("Fetching the HBV lookup forward value")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch HBV lookup forward value. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_hbv_prep_lkp_fwd_query = business_rules_queries.GET_HBV_LOOK_FWD_PERIOD_QUERY
            log.debug("Query to fetch HBV lookup forward value is:\n{}".format(
                get_hbv_prep_lkp_fwd_query))
            hbv_lkp_fwd_value = wr.athena.read_sql_query(sql=get_hbv_prep_lkp_fwd_query,
                                                         database=app_configurations.BUSINESS_RULES_STG_DB,
                                                         ctas_approach=False,
                                                         s3_output=s3_staging_dir,
                                                         boto3_session=boto_session)
            hbv_lkp_fwd_value = json.loads(hbv_lkp_fwd_value.to_json(orient="records"))[0][
                'PARM_VAL_1']
            log.debug("Fetched HBV lookup forward value successfully")
            return hbv_lkp_fwd_value

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_hbv_diags_cd(self, role_id):
        """
            Function to fetch the HBV diagnosis code
        :param role_id: Role Id
        :return: HBV diagnosis code
        """
        try:
            log.debug("Fetching the HBV diagnosis code")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch HBV diagnosis code. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_hbv_diags_cd_query = business_rules_queries.GET_HBV_DIAGS_CD_QUERY
            database1=app_configurations.BUSINESS_RULES_STG_DB
            print("Athena Database: ", database1)
            log.debug("Query to fetch HBV diagnosis code is:\n{}".format(get_hbv_diags_cd_query))
            hbv_diags_cd = wr.athena.read_sql_query(sql=get_hbv_diags_cd_query,
                                                    database=app_configurations.BUSINESS_RULES_STG_DB,
                                                    ctas_approach=False, s3_output=s3_staging_dir,
                                                    boto3_session=boto_session)
            hbv_diags_cd = json.loads(hbv_diags_cd.to_json(orient="records"))
            data = ""
            hbv_diags_cd_list = ""
            if len(hbv_diags_cd):
                for each in hbv_diags_cd:
                    data = data + each["PARM_VAL_1"] + ","
            if data != "":
                hbv_diags_cd_list = data[:-1]
            log.debug("Fetched HBV diagnosis code successfully")
            return hbv_diags_cd_list

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_pep_lkp_bck_value(self, role_id):
        """
            Function to fetch PrEP lookback value
        :param role_id: Role Id
        :return: PrEP lookback value
        """
        try:
            log.debug("Fetching the PrEP lookback value")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch PrEP lookback value. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_pep_lkp_bck_query = business_rules_queries.GET_PEP_LOOK_BACK_PERIOD_QUERY
            log.debug("Query to fetch PrEP lookback value is:\n{}".format(get_pep_lkp_bck_query))
            pep_lkp_bck_value = wr.athena.read_sql_query(sql=get_pep_lkp_bck_query,
                                                         database=app_configurations.BUSINESS_RULES_STG_DB,
                                                         ctas_approach=False,
                                                         s3_output=s3_staging_dir,
                                                         boto3_session=boto_session)
            pep_lkp_bck_value = json.loads(pep_lkp_bck_value.to_json(orient="records"))[0][
                'PARM_VAL_2']
            pep_lkp_bck_value = str(pep_lkp_bck_value).strip("-")
            log.debug("Fetched plan PrEP lookback value successfully")
            return pep_lkp_bck_value

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_pep_lkp_fwd_value(self, role_id):
        """
            Function to fetch the PrEP lookup forward value
        :param role_id: Role Id
        :return: PrEP lookup forward value
        """
        try:
            log.debug("Fetching the PrEP lookup forward value")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch PrEP lookup forward value. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_pep_lkp_fwd_query = business_rules_queries.GET_PEP_LOOK_FWD_PERIOD_QUERY
            log.debug("Query to fetch PrEP lookup forward value is:\n{}".format(
                get_pep_lkp_fwd_query))
            pep_lkp_fwd_value = wr.athena.read_sql_query(sql=get_pep_lkp_fwd_query,
                                                         database=app_configurations.BUSINESS_RULES_STG_DB,
                                                         ctas_approach=False,
                                                         s3_output=s3_staging_dir,
                                                         boto3_session=boto_session)
            pep_lkp_fwd_value = json.loads(pep_lkp_fwd_value.to_json(orient="records"))[0][
                'PARM_VAL_2']
            log.debug("Fetched PrEP lookup forward value successfully")
            return pep_lkp_fwd_value

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_plan_id_value(self, role_id):
        """
            Function to fetch the plan Id
        :param role_id: Role Id
        :return: Plan Id
        """
        try:
            log.debug("Fetching the plan Id")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch Plan Id. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_plan_id_exclusion_query = business_rules_queries.GET_PLAN_ID_EXCLUSION_QUERY
            log.debug("Query to fetch plan id is:\n{}".format(get_plan_id_exclusion_query))
            plan_id_value = wr.athena.read_sql_query(sql=get_plan_id_exclusion_query,
                                                     database=app_configurations.BUSINESS_RULES_STG_DB,
                                                     ctas_approach=False, s3_output=s3_staging_dir,
                                                     boto3_session=boto_session)
            plan_id_value = json.loads(plan_id_value.to_json(orient="records"))
            data = ""
            plan_id_value_list = ""
            if len(plan_id_value):
                for each in plan_id_value:
                    data = data + each["PARM_VAL_1"] + ","
            if data != "":
                plan_id_value_list = data[:-1]
            log.debug("Fetched plan id successfully")
            return plan_id_value_list

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_plan_payment_type_value(self, role_id):
        """
            Function to fetch the plan payment type
        :param role_id: Role Id
        :return: Plan payment type
        """
        try:
            log.debug("Fetching the plan payment type")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch plan payment type. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_plan_payment_type_query = business_rules_queries.GET_PLAN_PAYMENT_TYPE_QUERY
            log.debug("Query to fetch plan payment type:\n{}".format(get_plan_payment_type_query))
            plan_payment_type_value = wr.athena.read_sql_query(sql=get_plan_payment_type_query,
                                                               database=app_configurations.BUSINESS_RULES_STG_DB,
                                                               ctas_approach=False,
                                                               s3_output=s3_staging_dir,
                                                               boto3_session=boto_session)
            plan_payment_type_value = \
                json.loads(plan_payment_type_value.to_json(orient="records"))[0]['PARM_VAL_1']
            log.debug("Fetched plan payment type successfully")
            return [plan_payment_type_value]

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def get_cptr_ratio_value(self, role_id):
        """
        Function to fetch the capture ratio
        :param role_id: Role Id
        :return: Plan Id
        """
        try:
            log.debug("Fetching the capture ratio")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch capture ratio. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_cptr_ratio_query = business_rules_queries.GET_CPTR_RATIO_QUERY
            log.debug("Query to fetch capture ratio is:\n{}".format(get_cptr_ratio_query))
            cptr_ratio_value = wr.athena.read_sql_query(sql=get_cptr_ratio_query,
                                                     database=app_configurations.BUSINESS_RULES_STG_DB,
                                                     ctas_approach=False, s3_output=s3_staging_dir,
                                                     boto3_session=boto_session)
            cptr_ratio_value = json.loads(cptr_ratio_value.to_json(orient="records"))[0]['PARM_VAL_1']
            log.debug("Fetched capture ratio successfully")
            return cptr_ratio_value

        except ClientError as err:
            client_error(err)

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

    def create_patient_tagging_business_rule(self, patient_tagging_details: PatientTaggingDetails,
                                             userid, roleid,
                                             pageid):
        """
        :param patient_tagging_details: input parameters from UI
        :param userid: username of the logged in user
        :param roleid: id of the role assigned to that user
        :param pageid: id of the page for which user has access
        :return: status of rule created
        """
        try:
            log.info("Starting function to create_patient_tagging_business_rule...")
            log.debug("Creating a business rule id...")
            business_rule_id = datetime.utcnow().strftime('%Y%m-%d%H-%M%S-') + str(
                uuid.uuid4().hex[:8])
            log.debug("Business rule id: %s", business_rule_id)

            business_rule_details = {
                'business_rule_id': business_rule_id,
                'active_flag': 'N',
                'insert_date': datetime.strftime(datetime.utcnow(), "%Y-%m-%d")
            }

            value_list = []
            look_back_value = BusinessRulesForms.PATIENT_TAGGING_FIELDS['LKP_BCK']
            look_fwd_value = BusinessRulesForms.PATIENT_TAGGING_FIELDS['LKP_FWD']

            look_back_value[
                'param_val_3'] = f"-{patient_tagging_details.lkp_bck_hbv}" if patient_tagging_details.lkp_bck_hbv else None
            look_back_value[
                'param_val_1'] = f"-{patient_tagging_details.lkp_bck_prep}" if patient_tagging_details.lkp_bck_prep else None
            look_back_value[
                'param_val_2'] = f"-{patient_tagging_details.lkp_bck_pep}" if patient_tagging_details.lkp_bck_pep else None

            if look_back_value['param_val_3'] or look_back_value['param_val_1'] or look_back_value[
                'param_val_2']:
                value_list.append({**business_rule_details, **look_back_value})

            look_fwd_value[
                'param_val_3'] = patient_tagging_details.lkp_fwd_hbv if patient_tagging_details.lkp_fwd_hbv else None
            look_fwd_value[
                'param_val_1'] = patient_tagging_details.lkp_fwd_prep if patient_tagging_details.lkp_fwd_prep else None
            look_fwd_value[
                'param_val_2'] = patient_tagging_details.lkp_fwd_pep if patient_tagging_details.lkp_fwd_pep else None
            if look_fwd_value['param_val_3'] or look_fwd_value['param_val_1'] or look_fwd_value[
                'param_val_2']:
                value_list.append({**business_rule_details, **look_fwd_value})

            diags_codes = patient_tagging_details.hbv_diags_cd.split(
                ",") if patient_tagging_details.hbv_diags_cd else []

            for code in diags_codes:
                diags_code_value = BusinessRulesForms.PATIENT_TAGGING_FIELDS['HBV_DIAGS_CD']
                diags_code_value['param_val_1'] = code
                value_list.append({**business_rule_details, **diags_code_value})

            if patient_tagging_details.cptr_ratio:
                cptr_ratio_details = BusinessRulesForms.PATIENT_TAGGING_FIELDS['ACNT_SPLT']
                cptr_ratio_details['param_val_1'] = patient_tagging_details.cptr_ratio
                value_list.append({**business_rule_details, **cptr_ratio_details})

            if len(patient_tagging_details.plan_pmt_type) > 0:
                for pmt_type in patient_tagging_details.plan_pmt_type:
                    plan_pmt_type_details = BusinessRulesForms.PATIENT_TAGGING_FIELDS[
                        'PLAN_PAYMENT_TYPE_EXCLUSION']
                    plan_pmt_type_details['param_val_1'] = pmt_type
                    value_list.append({**business_rule_details, **plan_pmt_type_details})

            pap_plan_ids = patient_tagging_details.pap_plan_id.split(
                ",") if patient_tagging_details.pap_plan_id else []
            for plan_id in pap_plan_ids:
                pap_plan_id = BusinessRulesForms.PATIENT_TAGGING_FIELDS['PLAN_ID_EXCLUSION'][0]
                pap_plan_id['param_val_1'] = plan_id
                value_list.append({**business_rule_details, **pap_plan_id})
            data = list([tuple(a.values()) for a in value_list])

            log.info("Adding Patient tagging details...")
            add_patient_tagging_business_rule_query = business_rules_queries.CREATE_PATIENT_TAGGING_DETAILS_QUERY
            self.db_obj.execute_many(add_patient_tagging_business_rule_query, value_list=data)
            log.info("Added Patient tagging details successfully.")

            for rule in value_list:
                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=business_rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_PATIENT_TAGGING,
                    rule_value=json.dumps(rule),
                    userid=userid, roleid=roleid,
                    request_date=datetime.strftime(datetime.utcnow(), "%Y-%m-%d %H:%M:%S"))

                log.debug("Query to send request for approval after editing rule : %s",
                          approval_request_query)
                self.db_obj.raw_query(approval_request_query)

            action = app_constants.AuditLogs.ACTION_CREATE_BUSINESS_RULE
            message = app_constants.AuditLogs.MSG_CREATE_BUSINESS_RULE.format(
                business_rule_name="",
                rule_category_name=BusinessRulesForms.RULE_CATEGORY_PATIENT_TAGGING)
            self.audit_obj.save_audit_info(self.db_obj, userid, roleid, pageid,
                                           action, message)

            rule_category_value = "Patient Tagging"
            user_id_email_query = approval_requests_queries.requested_by_user_id_email_query.format(
                userid=userid)
            user_id_email = self.db_obj.raw_query(
                user_id_email_query)
            user_id_email = user_id_email[0][
                "email_id"]

            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + \
                              " --json_file_path " + config_dir_path + \
                              "/email_notification_configurations.json" + \
                              " --username " + '"' + user_id_email + '"' + " --rule_category " + \
                              '"' + rule_category_value + '"' + " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            with open(config_dir_path + "/email_notification_configurations.json") as f:
                data = json.load(f)
                data = data['NotificationUtility']
                ops_user_id_email = data["OPS_USER_MAIL_ID"]
            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + \
                              " --json_file_path " + config_dir_path + \
                              "/email_notification_configurations.json" + \
                              " --username " + '"' + ops_user_id_email + '"' + \
                              " --rule_created_by " + '"' + user_id_email + '"' + \
                              " --rule_category " + '"' + rule_category_value + '"' + \
                              " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            log.debug("Data inserted in rule table for request approval")
        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except IntegrityError as error:
            log.error(error)
            message = "Rule with same details already exists."
            raise HTTPException(status_code=500, detail=message) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_system_parameters_form(self, role_id):
        """
        Method to fetch System parameters form which has all the required UI fields
        :return: System Parameters form details
        """
        try:
            log.info("Fetching the System parameters form data")
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch Market Names. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Market Names...")
            get_vacancy_override_market_name_query = business_rules_queries.GET_VACANCY_OVERRIDE_MARKET_NAME_QUERY
            log.info("Query to fetch Market Name : %s", get_vacancy_override_market_name_query)
            market_name_list = wr.athena.read_sql_query(sql=get_vacancy_override_market_name_query,
                                                          database=app_configurations.BUSINESS_RULES_DW_DB,
                                                          ctas_approach=False,
                                                          s3_output=s3_staging_dir,
                                                          boto3_session=boto_session)
            market_name_list = json.loads(market_name_list.to_json(orient="records"))
            market_name = [{"bind_value": each["PRNT_SLS_FRC_NM"], "bind_label": each["PRNT_SLS_FRC_NM"]} for each in market_name_list]
            log.info("Market Names: %s", market_name)
            system_parameters_form = app_constants.BusinessRulesForms.system_params_form(
                call_types=list(),
                geography_ids=dict(),
                territory_ids=dict(), market_name = market_name)

            return system_parameters_form

        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_sys_params_call_types(self, role_id):
        try:
            log.info("Fetching the call types")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch call types. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Call type list...")
            get_call_types_query = business_rules_queries.GET_CALL_TYPES_QUERY
            call_types = wr.athena.read_sql_query(sql=get_call_types_query,
                                                  database=app_configurations.BUSINESS_RULES_STG_DB,
                                                  ctas_approach=False,
                                                  s3_output=s3_staging_dir,
                                                  boto3_session=boto_session)
            call_types = json.loads(call_types.to_json(orient="records"))
            return call_types
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_sys_params_geography_list(self, role_id):
        try:
            log.info("Fetching the System parameters form data")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch geography list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_geo_id_list_query = business_rules_queries.GET_GEOGRAPHY_ID_QUERY
            log.info("Query to fetch geography ids: %s", get_geo_id_list_query)
            geo_id_list = wr.athena.read_sql_query(sql=get_geo_id_list_query,
                                                   database=app_configurations.BUSINESS_RULES_DW_DB,
                                                   ctas_approach=False, s3_output=s3_staging_dir,
                                                   boto3_session=boto_session)
            geo_id_list = json.loads(geo_id_list.to_json(orient="records"))
            log.info("Geography ids list: %s", geo_id_list)

            geography_list = {}
            if geo_id_list:
                sorted_geos = sorted(
                    geo_id_list, key=itemgetter(BusinessRulesForms.COL_MKT_NM))
                for key, value in groupby(
                        sorted_geos, key=itemgetter(BusinessRulesForms.COL_MKT_NM)):
                    geo_list = [
                        {BusinessRulesForms.BIND_LABEL_KEY: i[BusinessRulesForms.BIND_LABEL_KEY],
                         BusinessRulesForms.BIND_VALUE_KEY: i[
                             BusinessRulesForms.BIND_VALUE_KEY]} for i in list(value)]
                    geography_list[key] = geo_list

            return geography_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def get_sys_params_territory_list(self, role_id):
        try:
            log.info("Fetching the System parameters form data")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch territory list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            get_terr_id_list_query = business_rules_queries.GET_TERRITORY_ID_QUERY
            log.info("Query to fetch territory ids: %s", get_terr_id_list_query)
            terr_id_list = wr.athena.read_sql_query(sql=get_terr_id_list_query,
                                                    database=app_configurations.BUSINESS_RULES_DW_DB,
                                                    ctas_approach=False, s3_output=s3_staging_dir,
                                                    boto3_session=boto_session)
            terr_id_list = json.loads(terr_id_list.to_json(orient="records"))
            log.info("Territory ids list: %s", terr_id_list)

            territory_list = {}
            if terr_id_list:
                sorted_geos = sorted(terr_id_list,
                                     key=itemgetter(
                                         BusinessRulesForms.COL_MKT_NM))
                for key, value in groupby(sorted_geos, key=itemgetter(
                        BusinessRulesForms.COL_MKT_NM)):
                    terr_list = [{BusinessRulesForms.BIND_LABEL_KEY: i[
                        BusinessRulesForms.BIND_LABEL_KEY],
                                  BusinessRulesForms.BIND_VALUE_KEY: i[
                                      BusinessRulesForms.BIND_VALUE_KEY]} for i
                                 in
                                 list(value)]
                    territory_list[key] = terr_list

            return territory_list
        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            log.error(error)
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.audit_obj
            try:
                del boto_session
            except (UnboundLocalError, NameError):
                pass

    def add_sys_params_business_rule(self, sys_param_details: SystemParamsDetails, userid, roleid,
                                     pageid):
        """
        :param sys_param_details: input parameters from UI
        :param userid: username of the logged in user
        :param roleid: id of the role assigned to that user
        :param pageid: id of the page for which user has access
        :return: status of rule created
        """
        try:
            log.info("Starting function to create_sys_params_business_rule...")
            log.debug("Creating a business rule id...")
            business_rule_id = datetime.utcnow().strftime('%Y%m-%d%H-%M%S-') + str(
                uuid.uuid4().hex[:8])
            log.debug("Business rule id: %s", business_rule_id)

            business_rule_details = {
                'rule_id': business_rule_id,
                'active_flag': 'N',
                'insert_date': datetime.strftime(datetime.utcnow(), "%Y-%m-%d")
            }
            if sys_param_details.call_type_grouping:
                value_list = []
                zoom = BusinessRulesForms.CALL_TYPE_GROUPING_FIELDS['zoom']
                telephonic = BusinessRulesForms.CALL_TYPE_GROUPING_FIELDS['telephonic']
                in_person = BusinessRulesForms.CALL_TYPE_GROUPING_FIELDS['in_person']

                if sys_param_details.call_type_grouping.zoom:
                    zoom_values = ", ".join(sys_param_details.call_type_grouping.zoom)
                    zoom['param_val_1'] = zoom_values
                    value_list.append({**business_rule_details, **zoom})
                if sys_param_details.call_type_grouping.telephonic:
                    telephonic_values = ", ".join(sys_param_details.call_type_grouping.telephonic)
                    telephonic['param_val_1'] = telephonic_values
                    value_list.append({**business_rule_details, **telephonic})
                if sys_param_details.call_type_grouping.in_person:
                    in_person_values = ", ".join(sys_param_details.call_type_grouping.in_person)
                    in_person['param_val_1'] = in_person_values
                    value_list.append({**business_rule_details, **in_person})

                call_type_grouping_data = list([tuple(a.values()) for a in value_list])

                log.info("Adding Call Type Grouping details...")
                add_call_type_grouping_details_query = business_rules_queries.ADD_CALL_TYPE_GROUPING_DETAILS_QUERY
                self.db_obj.execute_many(add_call_type_grouping_details_query,
                                         value_list=call_type_grouping_data)
                log.info("Added Call Type Grouping successfully.")
                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=business_rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_SYSTEM_PARAMS_C_TYPE_GRP,
                    rule_value=sys_param_details.call_type_grouping.json(),
                    userid=userid, roleid=roleid,
                    request_date=datetime.strftime(datetime.utcnow(), "%Y-%m-%d %H:%M:%S"))

                log.debug("Query to send request for approval after editing rule : %s",
                          approval_request_query)
                self.db_obj.raw_query(approval_request_query)

            if sys_param_details.employee_configuration:
                log.info("Adding Employee configuration details...")
                add_employee_config_query = business_rules_queries.ADD_EMPLOYEE_CONFIG_QUERY.format(
                    rule_id=business_rule_details['rule_id'],
                    employee_email_id=sys_param_details.employee_configuration.employee_email_id,
                    first_name=sys_param_details.employee_configuration.first_name,
                    last_name=sys_param_details.employee_configuration.last_name,
                    mkt_nm=sys_param_details.employee_configuration.mkt_emp_config,
                    user_title=sys_param_details.employee_configuration.user_title,
                    geography_id=sys_param_details.employee_configuration.geography_id,
                    active_flag=business_rule_details['active_flag'],
                    insert_date=business_rule_details['insert_date'])

                log.info("Query to add employee configuration details: %s",
                         add_employee_config_query)
                self.db_obj.raw_query(add_employee_config_query)
                log.info("Added Employee configuration details successfully.")
                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=business_rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_SYSTEM_PARAMS_EMP_CONFIG,
                    rule_value=sys_param_details.employee_configuration.json(),
                    userid=userid, roleid=roleid,
                    request_date=datetime.strftime(datetime.utcnow(), "%Y-%m-%d %H:%M:%S"))

                log.debug("Query to send request for approval after editing rule : %s",
                          approval_request_query)
                self.db_obj.raw_query(approval_request_query)

            if sys_param_details.vacancy_override:
                log.info("Adding Vacancy override details...")
                quarter = int(sys_param_details.vacancy_override.aligt_quarter[1])
                year = int(sys_param_details.vacancy_override.aligt_quarter[3:])
                quarter_start_dt = datetime(year, (3 * quarter - 2), 1)
                quarter_end_dt = datetime.combine(
                    datetime(year, (3 * quarter), monthrange(year, (3 * quarter))[1]),
                    time(23, 59, 59))

                add_vacancy_override_details_query = business_rules_queries.ADD_VACANCY_OVERRIDE_DETAILS_QUERY.format(
                    rule_id=business_rule_details['rule_id'],
                    mkt_nm=sys_param_details.vacancy_override.mkt_vacancy_override,
                    territory_id=sys_param_details.vacancy_override.territory_id[0],
                    geo_level_code=sys_param_details.vacancy_override.geo_level_code,
                    vacancy_flag=sys_param_details.vacancy_override.vacancy_flag,
                    quarter_start_dt=quarter_start_dt,
                    quarter_end_dt=quarter_end_dt,
                    aligt_quarter=sys_param_details.vacancy_override.aligt_quarter,
                    active_flag=business_rule_details['active_flag'],
                    insert_date=business_rule_details['insert_date'])

                log.info("Query to add vacancy override details: %s",
                         add_vacancy_override_details_query)
                self.db_obj.raw_query(add_vacancy_override_details_query)
                log.info("Added Vacancy Override details successfully.")
                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=business_rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_SYSTEM_PARAMS_VAC_OVERRIDE,
                    rule_value=sys_param_details.vacancy_override.json(),
                    userid=userid, roleid=roleid,
                    request_date=datetime.strftime(datetime.utcnow(), "%Y-%m-%d %H:%M:%S"))

                log.debug("Query to send request for approval after editing rule : %s",
                          approval_request_query)
                self.db_obj.raw_query(approval_request_query)

            action = app_constants.AuditLogs.ACTION_CREATE_BUSINESS_RULE
            message = app_constants.AuditLogs.MSG_CREATE_BUSINESS_RULE.format(
                business_rule_name="",
                rule_category_name=BusinessRulesForms.RULE_CATEGORY_SYSTEM_PARAMS)
            self.audit_obj.save_audit_info(self.db_obj, userid, roleid, pageid,
                                           action, message)

            rule_category_value = "Vacancy Override "
            user_id_email_query = approval_requests_queries.requested_by_user_id_email_query.format(
                userid=userid)
            user_id_email = self.db_obj.raw_query(
                user_id_email_query)
            user_id_email = user_id_email[0][
                "email_id"]

            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + " --json_file_path " + config_dir_path + "/email_notification_configurations.json" + \
                              " --username " + '"' + user_id_email + '"' + " --rule_category " + '"' + rule_category_value + '"' + " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            with open(config_dir_path + "/email_notification_configurations.json") as f:
                data = json.load(f)
                data = data['NotificationUtility']
                ops_user_id_email = data["OPS_USER_MAIL_ID"]
            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + \
                              " --json_file_path " + config_dir_path + \
                              "/email_notification_configurations.json" + \
                              " --username " + '"' + ops_user_id_email + '"' + \
                              " --rule_created_by " + '"' + user_id_email + '"' + \
                              " --rule_category " + '"' + rule_category_value + '"' + \
                              " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            log.debug("Data inserted in rule table for request approval")
        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except IntegrityError as error:
            log.error(error)
            message = "Rule with same details already exists."
            raise HTTPException(status_code=500, detail=message) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def load_product_form(self, role_id):
        try:
            log.debug("Loading product form")
            config_details = CommonUtility(self.db_obj).get_global_config_details(role_id=role_id,
                                                                                  param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch Data Sources. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.info("Getting Data Source names...")
            get_data_source_list_query = business_rules_queries.GET_DATA_SOURCE_LIST_QUERY
            log.info("Query to fetch Data Source name : %s", get_data_source_list_query)
            data_source_list_col = wr.athena.read_sql_query(sql=get_data_source_list_query,
                                                          database=app_configurations.BUSINESS_RULES_DW_DB,
                                                          ctas_approach=False,
                                                          s3_output=s3_staging_dir,
                                                          boto3_session=boto_session)
            data_source_list_col = json.loads(data_source_list_col.to_json(orient="records"))
            data_source_list = [{"bind_value": each["src_id_nm"], "bind_label": each["src_id_nm"]} for each in data_source_list_col]
            log.info("Data Source names: %s", data_source_list)
            form_fields, data = app_constants.BusinessRulesForms.product_form(data_source_list)
            data = {"form_fields": form_fields,
                    "data": data}
            log.debug("Loaded product form successfully")
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def save_product_details(self, input_data, user_id, role_id):
        try:
            log.debug("creating product rule details")
            market = input_data.market
            current_time = datetime.strftime(datetime.utcnow(), "%Y-%m-%d %H:%M:%S")
            current_date = datetime.strftime(datetime.utcnow(), "%Y-%m-%d")
            if input_data.product_configuration:
                log.debug("Creating product configuration of a rule")
                rule_id = datetime.utcnow().strftime(
                    '%Y%m-%d%H-%M%S-') + str(uuid.uuid4().hex[:8])
                add_product_configuration_values = ""
                for each in input_data.product_configuration_data.product_conf_table_data:
                    add_product_configuration_values += "{},".format(
                        business_rules_queries.add_product_configuration_values.format(
                            rule_id=rule_id,
                            market=market,
                            product_level=each.product_level,
                            product_name=each.product_name,
                            product_id=each.product_id,
                            bottle_factor=each.bottle_factor,
                            gilead_product=each.gilead_product,
                            generic_product=each.generic_product,
                            insert_date=current_date
                        ))
                if len(add_product_configuration_values):
                    add_product_configuration_values = add_product_configuration_values.rstrip(',')
                    add_product_configuration_query = business_rules_queries.add_product_configuration_query.format(
                        values=add_product_configuration_values)
                    log.debug("Query to create product configuration is : \n{}".format(
                        add_product_configuration_query))
                    self.db_obj.raw_query(add_product_configuration_query)
                    log.debug("Created product rule configuration successfully")

                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_PRODUCT_CONFIGURATION,
                    rule_value=input_data.product_configuration_data.json(),
                    userid=user_id, roleid=role_id,
                    request_date=current_time)
                log.debug("Query to send rule request for approval: \n{}".format(
                    approval_request_query))
                self.db_obj.raw_query(approval_request_query)
                log.debug("Product configuration rule is sent for approval")

            if input_data.source_product_mapping:
                log.debug("Creating product source mapping of a rule")
                rule_id = datetime.utcnow().strftime(
                    '%Y%m-%d%H-%M%S-') + str(uuid.uuid4().hex[:8])
                add_source_product_mapping_query = business_rules_queries.add_source_product_mapping.format(
                    rule_id=rule_id,
                    data_source=input_data.source_product_mapping_data.data_source,
                    product_level_to_map=input_data.source_product_mapping_data.product_level_to_map,
                    product_to_map=input_data.source_product_mapping_data.product_to_map,
                    source_product_mapping_id=input_data.source_product_mapping_data.source_product_mapping_id,
                    insert_date=current_date
                )
                log.debug("Query to create product source mapping is : \n{}".format(
                    add_source_product_mapping_query))
                self.db_obj.raw_query(add_source_product_mapping_query)
                log.debug("Created product rule source mapping successfully")

                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_PRODUCT_SOURCE_PROD_MAP,
                    rule_value=input_data.source_product_mapping_data.json(),
                    userid=user_id, roleid=role_id,
                    request_date=current_time)
                log.debug("Query to send rule request for approval: \n{}".format(
                    approval_request_query))
                self.db_obj.raw_query(approval_request_query)
                log.debug("product source mapping rule is sent for approval")

            if input_data.product_roll_ups:
                log.debug("Creating product roll-ups of a rule")
                rule_id = datetime.utcnow().strftime(
                    '%Y%m-%d%H-%M%S-') + str(uuid.uuid4().hex[:8])
                add_product_roll_ups_query = business_rules_queries.add_product_roll_ups.format(
                    rule_id=rule_id,
                    brand_to_roll_up=input_data.product_roll_ups_data.brand_to_roll_up,
                    product_group_to_roll_up_to=input_data.product_roll_ups_data.product_group_to_roll_up_to,
                    insert_date=current_date
                )
                log.debug("Query to create product roll-ups is : \n{}".format(
                    add_product_roll_ups_query))
                self.db_obj.raw_query(add_product_roll_ups_query)
                log.debug("Created product roll-ups successfully")

                approval_request_query = business_rules_queries.insert_rule_query.format(
                    rule_id=rule_id,
                    rule_category_name=BusinessRulesForms.RULE_CATEGORY_PRODUCT_ROLL_UPS,
                    rule_value=input_data.product_roll_ups_data.json(),
                    userid=user_id, roleid=role_id,
                    request_date=current_time)
                log.debug("Query to send rule request for approval: \n{}".format(
                    approval_request_query))
                self.db_obj.raw_query(approval_request_query)
                log.debug("product roll-ups rule is sent for approval")

            rule_category_value = "Product"
            user_id_email_query = approval_requests_queries.requested_by_user_id_email_query.format(
                userid=user_id)
            user_id_email = self.db_obj.raw_query(
                user_id_email_query)
            user_id_email = user_id_email[0]["email_id"]

            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + \
                              " --json_file_path " + config_dir_path + \
                              "/email_notification_configurations.json" + \
                              " --username " + '"' + user_id_email + '"' + " --rule_category " \
                              + '"' + rule_category_value + '"' + " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

            with open(
                    config_dir_path + "/email_notification_configurations.json") as f:
                data = json.load(f)
                data = data['NotificationUtility']
                ops_user_id_email = data["OPS_USER_MAIL_ID"]
            execute_command = "python " + utilities_dir_path + "/NotificationUtility.py" + \
                              " --json_file_path " + config_dir_path + \
                              "/email_notification_configurations.json" + \
                              " --username " + '"' + ops_user_id_email + '"' + \
                              " --rule_created_by " + '"' + user_id_email + '"' + \
                              " --rule_category " + '"' + rule_category_value + '"' + \
                              " --email_type create_rule"
            print(execute_command)
            log.info("Executing Email Notification")
            execute_command = os.system(execute_command)
            log.info(execute_command)
            log.info("Email send successfully to the requested user")
            if execute_command != 0:
                raise Exception("Failed to send email to user")

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def generate_product_id(self, role_id):
        try:
            log.debug("Generating product ID")
            query = business_rules_queries.get_max_brand_product_id
            log.debug("Query to fetch max brand Id is:\n{}".format(query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to generate product id. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.debug("Boto session established successfully")
            records = wr.athena.read_sql_query(sql=query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            results = json.loads(records.to_json(orient="records"))
            if len(results):
                product_id = results[0]["product_id"]
                max_cd = int(product_id.lower().replace('br', ''))
                new_cd = max_cd + 1
            else:
                new_cd = 1
            log.debug("fetched new brand Id")
            product_id = "BR{}".format(str(new_cd))
            data = {"product_id": product_id,
                    "id": "{}A".format(str(new_cd))}
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj
    
    def write_json_to_s3(self, bucket_name, key, data):
        response = dict()
        self.s3_client = boto3.client("s3")
        self.s3_resource = boto3.resource('s3')
        self.logger = logging.getLogger('save_file_to_s3')
        try:
            self.logger.info("Started function to upload the JSON to s3")
            self.logger.info("bucket_name===>>>"+str(bucket_name))
            self.logger.info("key====>>"+str(key))
            self.logger.info("data===>>>"+str(data))
            serialized_data = json.dumps(data)
            upload_data_response = self.s3_client.put_object(Bucket=bucket_name,
                                                             Key=key,
                                                             Body=serialized_data)
            if upload_data_response["ResponseMetadata"]["HTTPStatusCode"] == 200:
                self.logger.info("Successfully uploaded the file to s3")
                response[app_constants.MWAAConstants.STATUS_KEY] = app_constants.SUCCESS_STATUS
                response[app_constants.MWAAConstants.ERROR_KEY] = ""
                return response
            else:
                error = "Failed to write the file to s3"
                self.logger.error(error)
                response[app_constants.MWAAConstants.STATUS_KEY] = app_constants.FAILED_STATUS
                response[app_constants.MWAAConstants.ERROR_KEY] = error
                return response
        except Exception as ex:
            error = "Failed to write dict to s3 file. ERROR - " + str(ex)
            self.logger.error(error)
            response[app_constants.MWAAConstants.STATUS_KEY] = app_constants.FAILED_STATUS
            response[app_constants.MWAAConstants.ERROR_KEY] = error
            return response

    def list_history(self):
        try:
            log.debug("Getting latest 10 entries for each rule")
            records = {}

            '''
            hist_query=business_rules_queries.LIST_HISTORY_QUERY.format(table_name="custom_alignment_config_details")
            temp_output=self.db_obj.raw_query(hist_query)
            records["Alignment"]=temp_output
            hist_query=business_rules_queries.LIST_HISTORY_QUERY.format(table_name="custom_segmentation_details")
            temp_output=self.db_obj.raw_query(hist_query)
            records["Segmentation"]=temp_output
            hist_query=business_rules_queries.LIST_HISTORY_QUERY.format(table_name="custom_patient_tagging_details")
            temp_output=self.db_obj.raw_query(hist_query)
            records["Patient tagging details"]=temp_output
            hist_query=business_rules_queries.LIST_HISTORY_QUERY.format(table_name="custom_sys_param_call_type_grouping_details")
            temp_output=self.db_obj.raw_query(hist_query)
            records["System parameters"]=temp_output
            hist_query=business_rules_queries.LIST_HISTORY_QUERY.format(table_name="custom_product_configuration_details")
            temp_output=self.db_obj.raw_query(hist_query)
            records["Product config"]=temp_output
            #temp output is a list of dicts with col names as keys
            #records is a dict with rule name as key and the query output as values
            log.debug("Fetch successful")
            
            Alignment Config
            Alignment Exclusion
            Alignment Override
            Product - Product Configuration
            Product - Source Product Mapping
            Patient Tagging
            Product - Product Roll-ups
            segmentation
            '''

            # Alignment Config
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(category="Alignment Config", fix="1")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Alignment Config"] = temp_output
            row_id = 1
            fix = 1
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Alignment Exclusion
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(category="Alignment Exclusion",
                                                                                  fix="2")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Alignment Exclusion"] = temp_output
            row_id = 1
            fix = 2
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Alignment Override
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(category="Alignment Override",
                                                                                  fix="3")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Alignment Override"] = temp_output
            row_id = 1
            fix = 3
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Product - Product Configuration
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(
                category="Product - Product Configuration", fix="4")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Product - Product Configuration"] = temp_output
            row_id = 1
            fix = 4
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Product - Source Product Mapping
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(
                category="Product - Source Product Mapping", fix="5")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Product - Source Product Mapping"] = temp_output
            row_id = 1
            fix = 5
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Patient Tagging
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(category="Patient Tagging", fix="6")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Patient Tagging"] = temp_output
            row_id = 1
            fix = 6
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Product - Product Roll-ups
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(category="Product - Product Roll-ups",
                                                                                  fix="7")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Product - Product Roll-ups"] = temp_output
            row_id = 1
            fix = 7
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # Segmentation
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(category="Segmentation",
                                                                                  fix="8")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["Segmentation"] = temp_output
            row_id = 1
            fix = 8
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # System Parameters - Call Type Grouping
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(
                category="System Parameters - Call Type Grouping",
                fix="9")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["System Parameters - Call Type Grouping"] = temp_output
            row_id = 1
            fix = 9
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # System Parameters - Employee configuration
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(
                category="System Parameters - Employee configuration",
                fix="10")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["System Parameters - Employee configuration"] = temp_output
            row_id = 1
            fix = 10
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1

            # System Parameters - Vacancy Override
            hist_query = business_rules_queries.LIST_HISTORY_QUERY_UPDATED.format(
                category="System Parameters - Vacancy Override",
                fix="11")
            temp_output = self.db_obj.raw_query(hist_query)
            for each_rec in temp_output:
                each_rec['rule_value'] = json.loads(each_rec['rule_value'])
            records["System Parameters - Vacancy Override"] = temp_output
            row_id = 1
            fix = 11
            for each_record in temp_output:
                each_record["Version"] = str(fix) + ',' + str(row_id)
                row_id = row_id + 1
            
            data = json.dumps(records)  # string
            self.s3_client = boto3.client("s3")
            rule_json_write = self.s3_client.put_object(Bucket='gilead-commercial-dev-us-west-2-raw', Key='history_rule_file/', Body=data)

            response_dictionary = json.loads(data)  # json

            return response_dictionary

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def list_brand_products(self, market, role_id):
        try:
            log.debug("Fetching list of brand products")
            query = business_rules_queries.list_brand_products.format(market=market)
            log.debug("Query to fetch brand products is:\n{}".format(query))
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.debug("Boto session established successfully")
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch brand products. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            results = json.loads(records.to_json(orient="records"))
            log.debug("Fetched brand products successfully")
            data = [{"bind_value": each["chld_prod_nm"],
                     "bind_label": each["chld_prod_nm"]} for each in results]
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_brand_product_details(self, product_name, role_id):
        try:
            log.debug("Fetching details of a brand product")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            log.debug("Boto session established successfully")
            get_brand_product_details_query = business_rules_queries.get_brand_product_details.format(
                brd_nm=product_name)
            log.debug(
                "Query to fetch brand product ID is:\n{}".format(get_brand_product_details_query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch brand product details. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=get_brand_product_details_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            get_brand_product_details_results = json.loads(records.to_json(orient="records"))

            if len(get_brand_product_details_results) == 0:
                raise HTTPException(status_code=500, detail="Brand product details not found")
            brd_cd = get_brand_product_details_results[0]["product_id"]
            log.debug("Fetched brand product ID successfully")

            if len(get_brand_product_details_results) == 0:
                gilead_product_flg = 'N'
            else:
                if str(get_brand_product_details_results[0]["gild_prod_flg"]) == "1":
                    gilead_product_flg = 'Y'
                elif str(get_brand_product_details_results[0]["gild_prod_flg"]) == "0":
                    gilead_product_flg = 'N'
                else:
                    gilead_product_flg = get_brand_product_details_results[0]["gild_prod_flg"]
            log.debug("Fetched brand gilead product value")

            if len(get_brand_product_details_results) == 0:
                generic_product_flg = 'N'
            else:
                if str(get_brand_product_details_results[0]["gner_prod_flg"]) == "1":
                    generic_product_flg = 'Y'
                elif str(get_brand_product_details_results[0]["gner_prod_flg"]) == "0":
                    generic_product_flg = 'N'
                else:
                    generic_product_flg = get_brand_product_details_results[0]["gner_prod_flg"]
            log.debug("Fetched brand generic product value")

            data = {"product_name": product_name,
                    "product_id": brd_cd,
                    "gilead_product": gilead_product_flg,
                    "generic_product": generic_product_flg
                    }
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_max_fs_id(self, product_id, role_id):
        try:
            log.debug("Fetching details of a brand product")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            get_max_fs_prod_query = business_rules_queries.get_max_fs_prod.format(
                product_id=product_id)
            log.debug("Query to fetch max fs product code is:\n{}".format(get_max_fs_prod_query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch max fs product code. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=get_max_fs_prod_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            get_max_fs_prod_results = json.loads(records.to_json(orient="records"))

            log.debug("Fetched max fs code")
            if len(get_max_fs_prod_results) == 0:
                max_fs_cd = product_id.lower().replace('br', '')
                new_fs_cd = "{}A".format(max_fs_cd)
            else:
                max_fs_cd = get_max_fs_prod_results[0]["form_strg_cd"]
                new_fs_cd = "{}{}".format(max_fs_cd[:-1], chr(ord(max_fs_cd[-1]) + 1))
            log.debug("Fetched new fs code")

            data = {"max_fs_product_id": new_fs_cd}
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def list_fs_products(self, product_id, role_id):
        try:
            log.debug("Fetching list of form strengths")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            query = business_rules_queries.list_fs_products.format(product_id=product_id)
            log.debug("Query to list fs products is:\n{}".format(query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch fs product list. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            results = json.loads(records.to_json(orient="records"))
            log.debug("Fetched list of fs successfully")
            data = [{"bind_value": each["chld_prod_nm"],
                     "bind_label": each["chld_prod_nm"]} for each in results]
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_fs_product_id(self, product_name, role_id):
        try:
            log.debug("Fetching fs product details")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            get_fs_code_query = business_rules_queries.get_fs_code.format(
                fs_name=product_name)
            log.debug("Query to get fs code is:\n{}".format(get_fs_code_query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch fs code. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=get_fs_code_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            get_fs_code_results = json.loads(records.to_json(orient="records"))
            if len(get_fs_code_results) == 0:
                raise HTTPException(status_code=500,
                                    detail="Form strength product details not found")
            form_strg_cd = get_fs_code_results[0]["form_strg_cd"]

            data = {"product_name": product_name,
                    "product_id": form_strg_cd
                    }
            log.debug("Fetched fs product details successfully")

            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_fs_product_bottle_factor(self, product_name, role_id):
        try:
            log.debug("Fetching fs product bottle factor")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            bottle_factor_query = business_rules_queries.bottle_factor_query.format(
                fs_name=product_name)
            log.debug("Query to bottle factor value is:\n{}".format(bottle_factor_query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch bottle factor value. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=bottle_factor_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            bottle_factor_results = json.loads(records.to_json(orient="records"))
            if len(bottle_factor_results) == 0:
                raise HTTPException(status_code=500,
                                    detail="Form strength product details not found")
            log.info("Fetched bottle factor results successfully")
            bottle_factor = bottle_factor_results[0]["btl_fctr"]

            data = {"product_name": product_name,
                    "bottle_factor": bottle_factor
                    }
            log.debug("Fetched fs product details successfully")
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_source_product_details(self, request_body, role_id):
        try:
            log.debug("fetching source product details")
            data_source = request_body.data_source
            market = request_body.market
            src_prd_map_level = {"MODELN": "NDC",
                                 "CF_SP203": "NDC",
                                 "VA_PV": "Form Strength",
                                 "CF_SP200": "NDC",
                                 "SHA_PTD": "NDC",
                                 "CF_SP211": "NDC",
                                 "ICC": "NDC",
                                 "MCKESSON": "NDC",
                                 "CF_SP206": "NDC",
                                 "EPSILON": "NDC",
                                 "CF_SP205": "NDC",
                                 "CF_SP201": "NDC",
                                 "CF_SP202": "NDC",
                                 "ONC_SP614": "NDC",
                                 "ONC_SP605": "NDC",
                                 "UNASSIGNED": "NDC",
                                 "INTEGRICHAIN": "NDC",
                                 "SP_HCV": "NDC",
                                 "LEAP": "NDC",
                                 "INTERNAL": "NDC",
                                 "IQVIA": "NDC",
                                 "IQVIA XPO / LAAD": "NDC",
                                 "IQVIA DDD": "NDC",
                                 "IQVIA XPD": "Brand",
                                 "IQVIA LAAD": "NDC",
                                 "ONC_SP601": "NDC",
                                 "KNIPPER": "NDC",
                                 "CF_SP213": "NDC",
                                 "Veeva": "Brand",
                                 "GOLD": "NDC",
                                 "COVANCE": "NDC",
                                 "ONC_SP014": "NDC",
                                 "ACCREDO": "NDC",
                                 "ONC_SP604": "NDC",
                                 "ONC_SP603": "NDC",
                                 "CORE_ACCESS": "Brand",
                                 "CF_SP204": "NDC",
                                 "VA": "Form Strength",
                                 "ONC_SP606": "NDC",
                                 "ONC_SP602": "NDC"
                                 }
            if data_source in src_prd_map_level:
                prd_lvl_to_map = src_prd_map_level[data_source]
            else:
                raise HTTPException(status_code=500,
                                    detail="Product level not found for the selected data source")

            if prd_lvl_to_map.lower() == 'brand':
                product_to_map_query = business_rules_queries.prod_to_map_brand_query.format(
                    prod_nm=market)
            elif prd_lvl_to_map.lower() == 'form strength':
                product_to_map_query = business_rules_queries.prod_to_map_fs_query.format(
                    prod_nm=market)
            elif prd_lvl_to_map.lower() == 'ndc':
                product_to_map_query = business_rules_queries.prod_to_map_ndc_query.format(
                    prod_nm=market)
            else:
                raise HTTPException(status_code=500, detail="Product to map not found")

            product_to_map_query = product_to_map_query.format(prod_nm=request_body.market)
            log.debug("Query to product to map is:\n{}".format(product_to_map_query))

            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product to map details. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=product_to_map_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            results = json.loads(records.to_json(orient="records"))
            product_to_map = [{"bind_value": each["chld_prod_nm"],
                               "bind_label": each["chld_prod_nm"]} for each in results]

            data = {"product_level_to_map": prd_lvl_to_map,
                    "product_to_map": product_to_map
                    }
            log.debug("Fetched source product details successfully")
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_brand_roll_ups(self, market, role_id):
        try:
            log.debug("Fetching product brand roll up details")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)
            brand_to_roll_up_query = business_rules_queries.brand_to_roll_up_query.format(
                prd_nm=market)
            log.debug("Query to fetch brand to roll up is:\n{}".format(brand_to_roll_up_query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch brand to roll up details. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=brand_to_roll_up_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            brand_to_roll_up_results = json.loads(records.to_json(orient="records"))
            brand_to_roll_up = [
                {"bind_value": each["chld_prod_nm"],
                 "bind_label": each["chld_prod_nm"]} for each in brand_to_roll_up_results]

            data = {"brand_to_roll_up": brand_to_roll_up
                    }
            log.debug("Fetched product brand roll up details successfully")
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def get_product_group_roll_ups(self, market, role_id):
        try:
            log.debug("Fetching product group to roll up details")
            user_iam_role = CommonUtility(self.db_obj).get_user_iam_role(role_id=role_id)
            boto_session = get_boto3_session(assume_role_arn=user_iam_role)

            product_group_to_roll_up_query = business_rules_queries.product_group_to_roll_up_query
            log.debug("Query to fetch product group to roll up is:\n{}".format(
                product_group_to_roll_up_query))
            config_details = CommonUtility(self.db_obj).get_global_config_details(
                role_id=role_id, param_name='business_rules_configurations')
            if config_details == "":
                raise HTTPException(
                    status_code=500,
                    detail="Missing configuration details to fetch product group to roll up details. Please contact admin")
            s3_staging_dir = config_details['athena_s3_staging_dir']
            records = wr.athena.read_sql_query(sql=product_group_to_roll_up_query,
                                               database=app_configurations.BUSINESS_RULES_DW_DB,
                                               ctas_approach=False, s3_output=s3_staging_dir,
                                               boto3_session=boto_session)
            product_group_to_roll_up_results = json.loads(records.to_json(orient="records"))

            product_group_to_roll_up = [
                {"bind_value": each["prod_nm"],
                 "bind_label": each["prod_nm"]} for each in product_group_to_roll_up_results]

            data = {"product_group_to_roll_up_to": product_group_to_roll_up
                    }
            log.debug("Fetched product group to roll up details successfully")
            return data

        except KeyError as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except ClientError as err:
            client_error(err)

        except HTTPException as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            self.db_obj.db.rollback()
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
            del self.audit_obj

    def list_business_qc(self, request_body):
        """
        :param request_body: input parameters from UI
        :return: Business QC 
        """
        try:
            table_name = request_body.datasetName
            additional_filter = ""
            sort_by = ""
            if(table_name != ""):
                additional_filter = additional_filter + " and ctm.table_name like '%" + table_name + "%' "
            criticality = request_body.criticalityValue
            if(criticality != ""):
                additional_filter = additional_filter + " and cdm.criticality_threshold_pct like '%" + criticality + "%' "
            date_range = request_body.dateRange
            if(date_range != "latest_run" and date_range != ""):
                additional_filter = additional_filter + " and DATE(lds.qc_start_time) between (now() - interval " + date_range + ") and now() "     
            orderBy = request_body.orderBy
            orderBy = "cdm." + orderBy
            orderByValue = request_body.orderByValue
            if(orderBy != ""):
                sort_by = sort_by + " order by '" + orderBy + "' " + orderByValue
            limit = request_body.limit
            if(limit != 0):
                sort_by = sort_by + " limit " + str(limit)
            pageNumber = request_body.pageNumber
            offset = (pageNumber-1)*limit
            if(offset > -1):
                sort_by = sort_by + " offset " + str(offset)
            business_qc_query = business_rules_queries.BUSINESS_QC_QUERY.format()
            business_qc_query = business_qc_query + additional_filter + sort_by
            log.debug("Query to view Business QC:\n%s", business_qc_query)
            business_qc_query_result = self.db_obj.raw_query(business_qc_query)
            return business_qc_query_result

        except KeyError as error:
            traceback.print_exc()
            log.error(error)
            message = "Key not found - {}"
            raise HTTPException(status_code=500, detail=message.format(str(error))) from error

        except HTTPException as error:
            traceback.print_exc()
            raise HTTPException(status_code=error.status_code, detail=str(error.detail)) from error

        except Exception as error:
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(error)) from error

        finally:
            del self.db_obj
